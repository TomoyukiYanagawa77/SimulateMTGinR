## RでMagic:the Gatheringのゲームを再現する試み

## Google Colaboratory環境で必要となるライブラリや定数を設定する。
install.packages("tensorflow")
install.packages("keras")
library(tensorflow)
library(keras)

workDir <- "./"


## ローカル環境で必要となるライブラリや定数を設定する。
library(tidymodels)
library(tidyverse)
library(reticulate)
library(tensorflow)
library(keras)
reticulate::py_config()
workDir <- "C:/Yanagawa/R/"


## 定数定義
c_DECK_CARD_COUNT <- 60 ## 各デッキの枚数
c_CARD_STATUS_COUNT <- 7 ## カードの状態の数
c_ACTION_COUNT <- 19 ## アクションの数

## 各カードの状態を定義する。
c_CARD_STATUS_LIBRARY <- "d"	## ライブラリ内にある
c_CARD_STATUS_HAND <- "h"		## 手札にある
c_CARD_STATUS_BA_UNTAP <- "b"	## 場にアンタップ状態である
c_CARD_STATUS_BA_TAP <- "t"		## 場にタップ状態である
c_CARD_STATUS_BA_SS <- "s"		## 場に召喚酔い状態である
c_CARD_STATUS_GRAVEYARD <- "g"	## 墓地にある
c_CARD_STATUS_EXALED <- "e"		## 追放された

## カードステータスの並び替えの順番を定義しておく。
c_CARD_STATUS_ORDER <- c(c_CARD_STATUS_HAND, c_CARD_STATUS_BA_UNTAP, c_CARD_STATUS_BA_SS, c_CARD_STATUS_BA_TAP, c_CARD_STATUS_GRAVEYARD, c_CARD_STATUS_EXALED, c_CARD_STATUS_LIBRARY)


## 配列の定義

## HPとマナ
HP <- c(20,20)
Mana <- c(0, 0)


#### カード定義
##Cards <- tibble(
##	Id = c(1, 2, 101, 102),
##	Name = c("山", "森", "稲妻", "熊"),
##	Type = c("Land", "Land", "Instant", "Creature"),
##	ManaCost = c(0, 0, 1, 2),
##	Power = c(0, 0, 3, 2),
##	Toughness = c(0, 0, 0, 2)
##)
Cards <- readr::read_csv(
	str_c(workDir, "Cards.txt"), locale = locale(encoding = "UTF-8"), 
		skip = 1,
		col_names = c("Id","Name","Type","ManaCost","Power","Toughness"),
		col_types = cols(
			Id = col_integer(),
			Name = col_character(),
			Type = col_character(),
			ManaCost = col_integer(),
			Power = col_integer(),
			Toughness = col_integer()
		)
) 


## ライブラリの上と下の位置が分っているカードを保持する。
DeckOnTop <- list(list(), list())
DeckOnBottom <- list(list(), list())

## デッキを準備する
## 2020.12.23 高速化 (カードマスタのとinner_joinを１回だけにした)
## 2020.12.23 DeckOnTopとDeckOnBottomの初期化を追加。
MTG_Init <- function() {

	## 両プレイヤーのデッキ。
	## Cardがカードの種類
	## 2020.12.23 DeckRowを追加
	## 2021.02.02 カードのステータスを定数に変更
	Deck <- tibble(
		DeckRow = c(1:(c_DECK_CARD_COUNT * 2)),
		PlayerId = c(rep(1, c_DECK_CARD_COUNT), rep(2, c_DECK_CARD_COUNT)),
		Card = c(rep(0, (c_DECK_CARD_COUNT * 2))),
		Status = c(rep(c_CARD_STATUS_LIBRARY, (c_DECK_CARD_COUNT * 2)))
	)
	## すべてのカードをライブラリへおく
	Deck$Status <- c_CARD_STATUS_LIBRARY
	
	## 各プレイヤーのデッキを設定する。
	Deck <- MTG_SetDeck(Deck)
	
	## カードマスタとのinner_joinはここで１回だけやればいい
	Deck <- Deck %>% inner_join(Cards, by = c("Card" = "Id") )

	## ライブラリの上と下の位置が分っているカードのリストを空にする。
	DeckOnTop <<- list(list(), list())
	DeckOnBottom <<- list(list(), list())

	return(Deck)
}

## 各プレイヤーのデッキをデッキに入れる
MTG_SetDeck <- function(Deck) {

	## プレイヤー１のデッキ
	Deck$Card[1:20] <- 1
	Deck$Card[21:60] <- 3
	## プレイヤー２のデッキ
	Deck$Card[61:80] <- 2
	Deck$Card[81:120]<- 4
	
	return(Deck)
}

## MTG_Draw関数 ライブラリーからカードを引く
## Deck:使用中のDeck
## Player:どちらのプレイヤーのライブラリから引くか
## CardCount:引くカードの枚数
## 2020.12.25 ライブラリの上から引く処理とライブラリの底のカードを引かない処理を追加
MTG_Draw <- function(Deck, Player, CardCount) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (CardCount < 1 & CardCount > c_DECK_CARD_COUNT) { stop("引くカード枚数の指定が正しくありません") }

	drawCard = 0
	## DeckOnTopにカードがあったらそこから引く
	tempList <- DeckOnTop[[Player]]
	if (length(tempList) > 0) {
		while (drawCard < CardCount && length(tempList) > 0) {
			tempRow = tempList[ length(tempList) ]
			Deck$Status[tempRow] <- c_CARD_STATUS_HAND
			tempList[ length(tempList) ] <- NULL
			drawCard <- drawCard + 1
		}
		DeckOnTop[[Player]] <<- tempList
	}
	
	## ライブラリからランダムに１枚選ぶ
	while (drawCard < CardCount) {
		## お試しロジックなので、おバカコード
		n = as.integer(runif(1, min = 1, max = (c_DECK_CARD_COUNT + 1)) )
		if (Player == 2) { n = n + c_DECK_CARD_COUNT }
		if (Deck$Status[n] == c_CARD_STATUS_LIBRARY & MTG_CheckCardLibraryBottom(Player, n) == 0) { 
			Deck$Status[n] <- c_CARD_STATUS_HAND
			drawCard = drawCard + 1
		}
	}
	return(Deck)
}

## 対象プレイヤーの手札を確認する。
## Deck:使用中のDeck
## Player:どちらのプレイヤーのハンドを確認するか
MTG_Hand <- function(Deck, Player, flgShowCardName = FALSE) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }

	Hand <- Deck %>% filter(PlayerId == Player & Status == c_CARD_STATUS_HAND)
	
	if ( flgShowCardName) {
		if (nrow(Hand) > 0 ) {
			handStr <- str_c(Hand$Name, collapse = ",")
		} else {
			handStr = "(None)"
		}
		return(handStr)
	} else {
		return(Hand$Card)
	}
}

## 土地を置く
## Deck:使用中のDeck
## Player:どちらのプレイヤーの土地をおくか
## 2020.12.23 高速化（forループを使用しないようにした。）
MTG_SetLand <- function(Deck, Player) {

	## 対象プレイヤーの手札の土地カードを取得する。
	HandLand <- Deck %>% 
		filter(PlayerId == Player & Status == c_CARD_STATUS_HAND & Type == "Land")

	if (nrow(HandLand) > 0 ) {
		## 1枚だけ土地を戦場に出す
		Deck$Status[HandLand$DeckRow[1]] <- c_CARD_STATUS_BA_UNTAP
		## 関数外の値を更新するので <を２つ入れる。
		Mana[Player] <<- Mana[Player] + 1
	}
	return(Deck)
}

## スペルを使う
## Deck:使用中のDeck
## Player:どちらのプレイヤーがスペルを使うか
## 2020.12.23 高速化（だけどここだけはforループを使わざるを得ない）
MTG_PlaySpell <- function(Deck, Player) {

	## 対象プレイヤーの手札にInstantかCreatureがあるか？
	Hand <- Deck %>% 
		filter(PlayerId == Player & Status == c_CARD_STATUS_HAND & (Type == "Instant" | Type == "Creature") )

	if (nrow(Hand) > 0 ) {
		for(i in 1:nrow(Hand) ) {
			if ( Hand$ManaCost[i] <= Mana[Player] ) {
				if (Hand$Type[i] == "Instant") {
					## Instantがあった
					Opponent = MTG_GetOpponent(Player)
					Deck$Status[Hand$DeckRow[i]] <- c_CARD_STATUS_GRAVEYARD
					## 関数外の値を更新するので <を２つ入れる。
					HP[Opponent] <<- HP[Opponent] - Hand$Power[i]
					Mana[Player] <<- Mana[Player] - Hand$ManaCost[i]
				} else if (Hand$Type[i] == "Creature") {
					## Creature呪文があった
					Deck$Status[Hand$DeckRow[i]] <- c_CARD_STATUS_BA_SS
					## 関数外の値を更新するので <を２つ入れる。
					Mana[Player] <<- Mana[Player] - Hand$ManaCost[i]
				}
			}
		}
	}
	return(Deck)
}


## アタック
## Deck:使用中のDeck
## Player:どちらのプレイヤーが攻撃するか
## 2020.12.23 高速化（forループを使用しないようにした。）
## 2021.02.03 ブロッククリーチャーがあることを考慮するように変更した。
MTG_Attack <- function(Deck, Player, flgShowHistory = FALSE) {

	## 戦場にある攻撃や防御可能な生物カードを取得する。
	Opponent <- MTG_GetOpponent(Player)
	MyCreature <- Deck %>%
		dplyr::filter(PlayerId == Player, Type == "Creature", Status == c_CARD_STATUS_BA_UNTAP) %>%
		arrange(Power)
	OpponentCreature <- Deck %>%
		dplyr::filter(PlayerId == Opponent, Type == "Creature", Status %in% c(c_CARD_STATUS_BA_UNTAP, c_CARD_STATUS_BA_SS) ) %>%
		arrange(desc(Power))

	if (nrow(MyCreature) == 0) {
		## 攻撃クリーチャーがいないなら攻撃終了
		if (flgShowHistory == TRUE) {
			print("skip Attack")
		}
		return(Deck)
	}

	if (flgShowHistory == TRUE) {
		cat("Attacker Creature:")
		print(str_c(MyCreature$Name, collapse = ",") )
		if (nrow(OpponentCreature) > 0) {
			cat("Defender Creature:")
			print(str_c(OpponentCreature$Name, collapse = ",") )
		}
	}

	## 実際に攻撃するのは、山デッキは、防御側プレイヤーの生物に勝てるもので、森デッキは、防御側プレイヤーの生物と相打ち以上が出来るものだけ
	if (nrow(OpponentCreature) > 0) {
		if (Player == 1) {
			AttackingCreature <- dplyr::filter(MyCreature, Power > max(OpponentCreature$Toughness) )
		} else {
			AttackingCreature <- dplyr::filter(MyCreature, Power >= max(OpponentCreature$Toughness) )
		}
	} else {
		AttackingCreature <- MyCreature
	}

	if (flgShowHistory == TRUE) {
		cat("Attacking Creature:")
		print(str_c(AttackingCreature$Name, collapse = ",") )
	}
	
	## 攻撃したクリーチャーをタップ状態にする。
	Deck$Status[Deck$DeckRow %in% AttackingCreature$DeckRow] <- c_CARD_STATUS_BA_TAP

	if (nrow(AttackingCreature) > 0 & nrow(OpponentCreature) > 0) {
		## ブロック判定
		## 攻撃クリーチャーそれぞれについて
		for (i in 1:nrow(AttackingCreature)) {
			flgHasBlocked <- FALSE
			## まだブロックするクリーチャーが残っている。
			if (nrow(OpponentCreature) > 0) {
				if (Opponent == 1) {
					## 山デッキは一方的に勝てる場合だけブロックする。
					if (AttackingCreature$Power[i] < OpponentCreature$Toughness[1]) {
						flgHasBlocked <- TRUE
					}
				} else {
					## 森デッキは相打ちでもブロックする。
					if (AttackingCreature$Power[i] <= OpponentCreature$Toughness[1]) {
						flgHasBlocked <- TRUE
					}
				}
				if (flgHasBlocked == TRUE) {
					## ブロック成立
					if (AttackingCreature$Power[i] >= OpponentCreature$Toughness[1] ) {
						Deck$Status[OpponentCreature$DeckRow[1]] <- c_CARD_STATUS_GRAVEYARD
					}
					if (OpponentCreature$Power[1] >= AttackingCreature$Toughness[i] ) {
						Deck$Status[AttackingCreature$DeckRow[i]] <- c_CARD_STATUS_GRAVEYARD
						AttackingCreature$Status[i] <- c_CARD_STATUS_GRAVEYARD
					}
					## ブロックしたクリーチャーをプロッククリーチャーから取り除く
					OpponentCreature[1] <- NULL
				}
			}
		}
	}

	## ブロックで死亡したクリーチャーを除外する
	AttackingCreature <- dplyr::filter(AttackingCreature, Status != c_CARD_STATUS_GRAVEYARD)
	
	if (nrow(AttackingCreature) > 0 ) {
	
		if (flgShowHistory == TRUE) {
			cat("Suvived Attacker:")
			print(str_c(AttackingCreature$Name, collapse = ",") )
		}

		## 残ったAttackingCreatureのパワー分だけ相手プレイヤーのHPを減らす
		## 関数外の値を更新するので <を２つ入れる。
		HP[Opponent] <<- HP[Opponent] - sum(AttackingCreature$Power)
	}

	return(Deck)
}

## ターン開始時の処理など
## 今は、マナを入れる処理だけ
## Deck:使用中のDeck
## Player:どちらのプレイヤーの開始処理か
## 2021.02.02 クリーチャーのアンタップ処理を追加
MTG_TurnStart <- function(Deck, Player) {

	## 使用可能マナをセットする。
	BattleFieldLand <- Deck %>% filter(PlayerId == Player & Status == c_CARD_STATUS_BA_UNTAP & Type == "Land")
	Mana[Player] <<- nrow(BattleFieldLand)
	
	## 場に出てるクリーチャーをアンタップする。
	BattleFieldCreature <- Deck %>% filter(PlayerId == Player & Type == "Creature" & Status %in% c(c_CARD_STATUS_BA_TAP, c_CARD_STATUS_BA_SS) )

	Deck$Status[Deck$DeckRow %in% BattleFieldCreature$DeckRow] <- c_CARD_STATUS_BA_UNTAP

	return(Deck)
}

## ターン終了時の処理など
## 今はDiscardの処理だけ
## Deck:使用中のDeck
## Player:どちらのプレイヤーのターン終了時の処理か
## 2021.01.26 高速化ロジックで統一
MTG_TurnEnd <- function(Deck, Player) {

	Hand <- Deck %>% filter(PlayerId == Player & Status == c_CARD_STATUS_HAND)

	CardCount <- nrow(Hand)
	while (CardCount > 7) {
		n = as.integer(runif(1, min = 1, max = CardCount + 1) )
		Deck$Status[Hand$DeckRow[n]] <- c_CARD_STATUS_GRAVEYARD
		CardCount = CardCount - 1
	}
	
	## PowerとToughnessを更新するためにCardマスターと再度マッチさせる。
	Deck <- dplyr::select(Deck, DeckRow, PlayerId, Card, Status)
	Deck <- Deck %>% inner_join(Cards, by = c("Card" = "Id") )

	return(Deck)
}

## 手番プレイヤーを交代する。
## ActivePlayer:現在の手番プレイヤー
MTG_SwitchPlayer <- function(ActivePlayer) {
	
	NextPlayer <- MTG_GetOpponent(ActivePlayer)
	return(NextPlayer)
}

## 勝利条件の判定をする
MTG_CheckVictory <- function() {

	WinPlayer = 0
	if (HP[1] <= 0) {
		WinPlayer = 2
	} else if (HP[2] <= 0 ) {
		WinPlayer = 1
	}
	return (WinPlayer)
}



## 高速化の時間測定用

## まずは、どの処理にどれだけ時間が掛かっているか分らないと高速化しようがないので、時間を計ります。
## なんか思っていたようなPackageがなかったので、これも自作します。（tictocは、よさげでした）
TimeVault <- as_tibble( data.frame(processName=character(), Time= as.Date(character()) ) )
Teferi <- function(ProcessName) {
	if (ProcessName == "Init") {
		TimeVault <<- as_tibble( data.frame(processName=character(), Time= as.Date(character()) ) )
	}
	TimeVault <<- rbind(TimeVault, data.frame(ProcessName, Time = Sys.time()) )
}


## Logをどうするか考える。
## 名称はGameLog で、DataFrame
## RandomSeed
## 勝利プレイヤー
## 先手プレイヤー
## HPWin
## HPLose
## TurnCount

## GameHistory## は同じRandomSeedを渡すことで再現できる

## ゲームを進行させる。
## RandomSeed:乱数の元（デフォルトは0で指定しない）
## flgShowHistory:対戦経過をConsoleへ出力するか
## 2020.12.22 処理時間を計る処理を追加
## 2020.12.25 マリガンをする／しないを追加
## 2021.02.03 ブロック処理などを追加
MentalNote <- function(RandomSeed = 0, flgShowHistory = FALSE, flgDoMulligan = TRUE) {

##Teferi("Init")

	## デッキを準備する。
	Deck <- MTG_Init()

##Teferi("SetRandomSeed")

	## 乱数の元が指定されていたらセットする。（同じ展開になる）
	if (RandomSeed != 0) {
		set.seed(RandomSeed)
	}

##Teferi("DrawInitialHand")

	## 初期手札を決める。
	Deck <- MTG_Draw(Deck, 1, 7)
	Deck <- MTG_Draw(Deck, 2, 7)
	
	## ライフとマナの初期値を設定する。
	HP <<- c(20,20)
	Mana <<- c(0, 0)

##Teferi("DecideFirstPlayer")

	## 先手プレイヤーを決める
	TurnCount = 1
	FirstPlayer = as.integer(runif(1, min = 1, max =3) )
	ActivePlayer = FirstPlayer
	
	if (flgDoMulligan == TRUE) {
		## 先手側マリガン処理
		Deck <- MTG_Mulligan(Deck, ActivePlayer, FirstPlayer, flgShowHistory)
		## 後手側マリガン処理
		Deck <- MTG_Mulligan(Deck, MTG_GetOpponent(ActivePlayer), FirstPlayer, flgShowHistory)
	}		
	
	## 勝敗が付くまでターンを進める。
	WinPlayer <- MTG_CheckVictory()
	while (WinPlayer == 0 && TurnCount <= ((c_DECK_CARD_COUNT - 7) *2 + 1) ) {

##Teferi("TurnStart")

		if (flgShowHistory == TRUE) {
			cat(TurnCount)
			cat("ターン目\n")
		}
		
		## アンタップ、アップキープ
		Deck <- MTG_TurnStart(Deck, ActivePlayer)

##Teferi("TurnDraw")

		## 先手１ターン目はドローなし
		if (TurnCount > 1) {
			Deck <- MTG_Draw(Deck, ActivePlayer, 1)
		}

##Teferi("TurnDoMain")

		## 第一メインフェイズ
		Deck <- MTG_DoMain(Deck, ActivePlayer, flgShowHistory)
		
##Teferi("TurnAttack")

		## 攻撃フェイズ
		Deck <- MTG_Attack(Deck, ActivePlayer, flgShowHistory)
		
##Teferi("TurnCheckVictory")

		WinPlayer <- MTG_CheckVictory()

##Teferi("TurnEnd")

		## 終了フェイズ
		Deck <- MTG_TurnEnd(Deck, ActivePlayer)
		
##Teferi("TurnShowHistory")

		## コンソールに途中経過を出力する。
		if (flgShowHistory == TRUE) {
			Creature <- dplyr::filter(Deck, Type == "Creature", Status %in% c(c_CARD_STATUS_BA_UNTAP, c_CARD_STATUS_BA_TAP, c_CARD_STATUS_BA_SS))
			if (ActivePlayer == 1) {
				cat("山デッキ（手札）:")
				cat(MTG_Hand(Deck, 1, TRUE))
				cat("\n")
				cat("山デッキ（場）:")
				cat(str_c(dplyr::filter(Creature, PlayerId == 1)$Name, collapse = ","))
				cat("\n")
				cat("森デッキ（場）:")
				cat(str_c(dplyr::filter(Creature, PlayerId == 2)$Name, collapse = ","))
				cat("\n")
			} else {
				cat("森デッキ（手札）:")
				cat(MTG_Hand(Deck, 2, TRUE))
				cat("\n")
				cat("森デッキ（場）:")
				cat(str_c(dplyr::filter(Creature, PlayerId == 2)$Name, collapse = ","))
				cat("\n")
				cat("山デッキ（場）:")
				cat(str_c(dplyr::filter(Creature, PlayerId == 1)$Name, collapse = ","))
				cat("\n")
			}
			print(HP)
			print(Mana)
		}
		
		if (WinPlayer != 0) {
			break
		}
		
		ActivePlayer = MTG_SwitchPlayer(ActivePlayer)
		TurnCount = TurnCount + 1
	}
	
	## ゲームを記録して終了。
	if (WinPlayer != 0) {
		LosePlayer = MTG_GetOpponent(WinPlayer)
		GameLog <- data.frame(
			"RandomSeed" = RandomSeed,
			"WinPlayer" = WinPlayer,
			"FirstPlayer" = FirstPlayer,
			"HPWin" = HP[WinPlayer],
			"HPLose" = HP[LosePlayer],
			"finalTurn" = TurnCount
		)
	} else {
		GameLog <- data.frame(
			"RandomSeed" = RandomSeed,
			"WinPlayer" = 0,
			"FirstPlayer" = FirstPlayer,
			"HPWin" = HP[1],
			"HPLose" = HP[2],
			"finalTurn" = TurnCount
		)
	}
	return(GameLog)
}



## 最後にｎ回シミュレートさせる関数を作る。
## LoopCount:試行回数
## StartSeed:乱数の元の開始番号
## 2021.01.26 runMethodを追加:シミュレートさせる関数名
AccumulateKnowledge <- function(LoopCount, StartSeed, runMethod = "MentalNote", flgDoMulligan = TRUE) {
	## 引数のエラー処理
	if (LoopCount < 1) { stop("試行回数は1以上を指定してください。") }
	if (runMethod %in% c("MentalNote", "GoblinLore", "GreedyGoblin", "DQN") == FALSE) { stop("シミュレート手段の指定が正しくありません") }

	StartTime = Sys.time()
	print(StartTime)
	for(i in 1:LoopCount) {
		cat(str_c(i, LoopCount, sep = "/"))
		cat("\r")
		if (runMethod == "MentalNote") {
			Result <- MentalNote(StartSeed + i - 1, FALSE, flgDoMulligan)
		} else if (runMethod == "GoblinLore") {
			Result <- GoblinLore("Random", StartSeed + i - 1, FALSE)
		} else if (runMethod == "GreedyGoblin") {
			Result <- GoblinLore("Greedy", StartSeed + i - 1, FALSE)
		} else if (runMethod == "DQN") {
			Result <- GoblinLore("DQN", StartSeed + i - 1, FALSE)
		}
		if ( i == 1 ) {
			TotalResult <- Result
		} else {
			TotalResult <- rbind(TotalResult, Result)
		}
	}
	EndTime = Sys.time()
	print(EndTime)
	print(EndTime - StartTime)
	
	return(TotalResult)
}


## ロンドンマリガンで、毎回7枚引いて、マリガン回数分のカードを山札の最後に戻す。

## さて、ここで山札の底のカードや上のカードの処理を先に作ります。
## 当然ドローの処理も変更になるので、あわせて修正します。

## 実装方法はいくつか考えられますが、MTGではあまり、ライブラリの順番が分っていることは少ないので、いつものようにリストで表現します。
## DeckOnTopとDeckOnBottomがそれぞれ、ライブラリの上のカードと底のカードを表していて、このリストがNULLのときは、分っているときはない状態です。
## 上からどんどんカードを置いていって、ドローするときには上のカードを引くのでLILO（Last in Last out)です。
##DeckOnTop <- list(list(), list())
##DeckOnBottom <- list(list(), list())

## 指定したDeckRowのカードがLibraryTopにあるか確認する。
## flgIsRemoveCard:指定したDeckRowのカードをLibraryTopから削除する。
## 戻り値:指定したカードがあるならDeckRowが、ないなら0を返す。
MTG_CheckCardLibraryTop <- function(Player, DeckRow, flgIsRemoveCard = FALSE) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (Player == 1 & ( DeckRow < 1 | DeckRow > c_DECK_CARD_COUNT) ) { stop("カードの指定が正しくありません") }
	if (Player == 2 & ( DeckRow < c_DECK_CARD_COUNT | DeckRow > (c_DECK_CARD_COUNT * 2)) ) { stop("カードの指定が正しくありません") }
	
	tempRow <- list()
	tempList <- DeckOnTop[[Player]]
	if (length(tempList) > 0) {
		tempRow <- tempList[tempList == DeckRow]
		if (length(tempRow) > 0 ) {
			if (tempRow == DeckRow & flgIsRemoveCard) {
				tempList[tempList == DeckRow] <- NULL
				DeckOnTop[[Player]] <<- tempList
			}
		}
	}
	if (length(tempRow) == 0) {
		return( 0 )
	} else {
		return( DeckRow )
	}
}

## 指定したDeckRowのカードがLibraryBottomにあるか確認する。
## flgIsRemoveCard:指定したDeckRowのカードをLibraryBottomから削除する。
## 戻り値:指定したカードがあるならDeckRowが、ないなら0を返す。
MTG_CheckCardLibraryBottom <- function(Player, DeckRow, flgIsRemoveCard = FALSE) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (Player == 1 & ( DeckRow < 1 | DeckRow > c_DECK_CARD_COUNT) ) { stop("カードの指定が正しくありません") }
	if (Player == 2 & ( DeckRow < c_DECK_CARD_COUNT | DeckRow > (c_DECK_CARD_COUNT * 2)) ) { stop("カードの指定が正しくありません") }
	
	tempRow <- list()
	tempList <- DeckOnBottom[[Player]]
	if (length(tempList) > 0) {
		tempRow <- tempList[tempList == DeckRow]
		if (length(tempRow) > 0 ) {
			if (tempRow == DeckRow & flgIsRemoveCard) {
				tempList[tempList == DeckRow] <- NULL
				DeckOnBottom[[Player]] <<- tempList
			}
		}
	}
	if (length(tempRow) == 0) {
		return( 0 )
	} else {
		return( DeckRow )
	}
}

## DeckRowのカードをライブラリの上に乗せる。
MTG_SetCardLibraryTop <- function(Deck, Player, DeckRow) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (Player == 1 & ( DeckRow < 1 | DeckRow > c_DECK_CARD_COUNT) ) { stop("カードの指定が正しくありません") }
	if (Player == 2 & ( DeckRow < c_DECK_CARD_COUNT | DeckRow > (c_DECK_CARD_COUNT * 2)) ) { stop("カードの指定が正しくありません") }
	
	## 指定されたカードが既にライブラリの上や底にあったら削除する。
	tempRow <- MTG_CheckCardLibraryTop(Player, DeckRow, TRUE)
	tempRow <- MTG_CheckCardLibraryBottom(Player, DeckRow, TRUE)
	
	tempList <- DeckOnTop[[Player]]
	if (length(tempList) > 0) {
		tempList[length(tempList)+1] <- DeckRow
	} else {
		tempList[1] <- DeckRow
	}
	DeckOnTop[[Player]] <<- tempList
	Deck$Status[DeckRow] <- c_CARD_STATUS_LIBRARY
	
	return(Deck)
}

## DeckRowのカードをライブラリの底に入れる。。
MTG_SetCardLibraryBottom <- function(Deck, Player, DeckRow) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (Player == 1 & ( DeckRow < 1 | DeckRow > c_DECK_CARD_COUNT) ) { stop("カードの指定が正しくありません") }
	if (Player == 2 & ( DeckRow < c_DECK_CARD_COUNT | DeckRow > (c_DECK_CARD_COUNT * 2)) ) { stop("カードの指定が正しくありません") }
	
	## 指定されたカードが既にライブラリの上や底にあったら削除する。
	tempRow <- MTG_CheckCardLibraryTop(Player, DeckRow, TRUE)
	tempRow <- MTG_CheckCardLibraryBottom(Player, DeckRow, TRUE)
	
	tempList <- DeckOnBottom[[Player]]
	if (length(tempList) > 0) {
		tempList[length(tempList)+1] <- DeckRow
	} else {
		tempList[1] <- DeckRow
	}
	DeckOnBottom[[Player]] <<- tempList
	Deck$Status[DeckRow] <- c_CARD_STATUS_LIBRARY
	
	return(Deck)
}


## マリガン処理（ロンドンマリガン、7枚引いてマリガン回数分のカードをライブラリの底に置く）
## マリガン判定のルール（私が、勝手に決めた）
## 手札が4枚になるまではマリガンする。
## 土地が1枚もないか、土地が4枚以上ならマリガン
## 土地1枚は、先行なら手札が7枚の時はマリガン、後攻ならマリガンしない。

## Player:どちらのプレイヤーのマリガンの処理か
## FirstPlayer:最初にプレイするプレイヤー
## flgShowHistory:対戦経過をConsoleへ出力するか
MTG_Mulligan <- function(Deck, Player, FirstPlayer, flgShowHistory) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (FirstPlayer < 1 & FirstPlayer > 2) { stop("先手プレイヤの指定が正しくありません") }

	MulliganCount <- 0
	while (MulliganCount < 3) {
		LandCards <- Deck %>% filter(PlayerId == Player & Status == c_CARD_STATUS_HAND & Type == "Land")
	
		if (nrow(LandCards) > 1 & nrow(LandCards) < 5) {
			## 土地が2枚から4枚はマリガンしない
			break
		} else if (nrow(LandCards) == 1) {
			## 土地1枚は、後手か、先手の手札6枚以下ならマリガンしない
			if (Player != FirstPlayer | MulliganCount > 0) {
				break
			}
		}
		## ここまで来たら、マリガンします。マリガン前の手札を表示しておく
		if (flgShowHistory == TRUE) {
			cat("Mulligan ")
			print(MulliganCount)
			print(MTG_Hand(Deck, Player, TRUE) )
		}
		## 手札のカードをライブラリに戻す。
		Deck$Status[Deck$PlayerId == Player] <- c_CARD_STATUS_LIBRARY

		## 新しい手札を引く
		Deck <- MTG_Draw(Deck, Player, 7)
		
		MulliganCount <- MulliganCount + 1
	}
	
	if (MulliganCount > 0) {
		## 1回以上マリガンしたら、手札をマリガン回数枚ライブラリの底に置く
		while( MulliganCount > 0 ) {
			## 土地が3枚以上なら土地を置く
			LandCards <- Deck %>% filter(PlayerId == Player & Status == c_CARD_STATUS_LIBRARY & Type == "Land")
			if (nrow(LandCards) > 2) {
				tempRow <- LandCards$DeckRow[1]
			} else {
				NotLandCards <- Deck %>% filter(PlayerId == Player & Status == c_CARD_STATUS_LIBRARY & Type != "Land")
				tempRow <- NotLandCards$DeckRow[1]
			}
			Deck <- MTG_SetCardLibraryBottom(Deck, Player, tempRow)
		
			MulliganCount <- MulliganCount - 1
		}
		## マリガン後の手札を表示しておく
		if (flgShowHistory == TRUE) {
			print("After Mulligan")
			print(MTG_Hand(Deck, Player, TRUE) )
		}
		
	}

	return(Deck)
}

## デッキを変更して、ブロックやクリーチャーにスペルを撃つ処理を追加する。
c_DECK_CARD_COUNT = 15

## 各プレイヤーのデッキをデッキに入れる
MTG_SetDeck <- function(Deck) {

	## プレイヤー１のデッキ
	Deck$Card[1:5] <- 1
	Deck$Card[6:7] <- 5
	Deck$Card[8:9] <- 6
	Deck$Card[10:11] <- 7
	Deck$Card[12:15] <- 3
	## プレイヤー２のデッキ
	Deck$Card[16:20] <- 2
	Deck$Card[21:24] <- 8
	Deck$Card[25:28] <- 4
	Deck$Card[29:30] <- 9
	
	return(Deck)
}

## 対戦相手のプレイヤーを求める。
MTG_GetOpponent <- function(Player) {

	Opponent = 1
	if (Player == 1) {
		Opponent <- 2
	}
	return(Opponent)
}


## メインフェイズをプレイする。
MTG_DoMain <- function(Deck, Player, flgShowHistory = FALSE) {

	## 土地をセットする
	Deck <- MTG_SetLand(Deck, Player)

	Opponent <- MTG_GetOpponent(Player)
	MyCreature <- dplyr::filter(Deck, PlayerId == Player, Type == "Creature", Status == c_CARD_STATUS_BA_UNTAP)
	OpponentCreature <- Deck %>%
		dplyr::filter(PlayerId == Opponent, Type == "Creature", Status %in% c(c_CARD_STATUS_BA_UNTAP, c_CARD_STATUS_BA_SS) ) %>%
		arrange(desc(Toughness))

	if (nrow(OpponentCreature) > 0 & nrow(MyCreature) > 0) {
		## 対戦相手にアンタップ状態のクリーチャーがいる。
		
		if( max(MyCreature$Power) <= max(OpponentCreature$Power) ) {
			## 自分のクリーチャーでは乗り越えられない。
			
			MySpell <- dplyr::filter(Deck, PlayerId == Player, Type == "Instant", Status == c_CARD_STATUS_HAND)
			if (nrow(MySpell) > 0 ) {
				if ( max(MySpell$Power) >= OpponentCreature$Toughness[1] ) {
					## 対象をスペルで焼ける
					if (flgShowHistory == TRUE) {
						cat("Spell4Creature:")
						print(OpponentCreature$Name[1])
					}
					Deck <- MTG_PlaySpell4Creature(Deck, Player, OpponentCreature$DeckRow[1])
				}
			}
		}
	}
	
	## 生物を召喚する。
	Deck <- MTG_SummonCreature(Deck, Player)

	## 対戦相手にクリーチャーがいないか、手札の火力が相手のHPより多いか、ディスカードするなら対戦相手にスペルを撃つ。
	MyHand <- dplyr::filter(Deck, PlayerId == Player, Status == c_CARD_STATUS_HAND)
	SpellPower <- sum( dplyr::filter(MyHand, Type == "Instant")$Power )
	OpponentCreature <- dplyr::filter(Deck, PlayerId == Opponent, Type == "Creature", Status %in% c(c_CARD_STATUS_BA_UNTAP, c_CARD_STATUS_BA_TAP, c_CARD_STATUS_BA_SS) )
	if (Mana[Player] > 0 & (nrow(MyHand) > 7 | SpellPower >= HP[Opponent] | nrow(OpponentCreature) == 0)) {
		if (flgShowHistory == TRUE) {
			cat("Spell4Opponent:")
			print(str_c(MyHand$Name, collapse = ",") )
		}

		Deck <- MTG_PlaySpell4Opponent(Deck, Player)
	}
	
	return(Deck)
}

## 生物呪文を唱える（クリーチャーを召喚する。）
## 2021.02.18 CardIdを追加。
MTG_SummonCreature <- function(Deck, Player, CardId = NULL) {

	if (is.null(CardId) ) {
		## カードが指定されない時は、マナの続く限り生物を召喚する。
		CreatureSpell <- Deck %>% 
			dplyr::filter(PlayerId == Player, Type == "Creature", Status == c_CARD_STATUS_HAND) %>%
			arrange(desc(ManaCost))
		
		if (nrow(CreatureSpell) > 0 & Mana[Player] > 0 ) {
			for (i in 1:nrow(CreatureSpell)) {
				if ( CreatureSpell$ManaCost[i] <= Mana[Player] ) {
					Deck$Status[CreatureSpell$DeckRow[i]] <- c_CARD_STATUS_BA_SS
					## 関数外の値を更新するので <を２つ入れる。
					Mana[Player] <<- Mana[Player] - CreatureSpell$ManaCost[i]
				}
			}
		}
	} else {
		## 手札から指定されたカードを探す。
		CreatureSpell <- dplyr::filter(Deck, PlayerId == Player, Card == CardId, Status == c_CARD_STATUS_HAND)
		
		if (nrow(CreatureSpell) > 0 & Mana[Player] > 0 ) {
			## 召喚する生物は１体だけ
			if ( CreatureSpell$ManaCost[1] <= Mana[Player] ) {
				Deck$Status[CreatureSpell$DeckRow[1]] <- c_CARD_STATUS_BA_SS
				## 関数外の値を更新するので <を２つ入れる。
				Mana[Player] <<- Mana[Player] - CreatureSpell$ManaCost[1]
			}
		}
	
	}
	
	return(Deck)
}

## 対戦相手に呪文を唱える
## 2021.02.18 CardIdを追加。
MTG_PlaySpell4Opponent <- function(Deck, Player, CardId = NULL) {

	Opponent <- MTG_GetOpponent(Player)
	
	if (is.null(CardId) ) {
		## カードが指定されない時は、マナの続く限りスペルを撃つ。
		Spell <- Deck %>% 
			dplyr::filter(PlayerId == Player, Type == "Instant", Status == c_CARD_STATUS_HAND) %>%
			arrange(ManaCost)
		
		if (nrow(Spell) > 0 & Mana[Player] > 0 ) {
			for (i in 1:nrow(Spell)) {
				if ( Spell$ManaCost[i] <= Mana[Player] ) {
					Deck$Status[Spell$DeckRow[i]] <- c_CARD_STATUS_GRAVEYARD
					## 関数外の値を更新するので <を２つ入れる。
					Mana[Player] <<- Mana[Player] - Spell$ManaCost[i]
					HP[Opponent] <<- HP[Opponent] - Spell$Power[i]
				}
			}
		}
	} else {
		## 手札から指定されたカードを探す。
		Spell <- dplyr::filter(Deck, PlayerId == Player, Card == CardId, Status == c_CARD_STATUS_HAND)
		if (nrow(Spell) > 0 & Mana[Player] > 0 ) {
			## 使用するスペルは１つだけ
			if ( Spell$ManaCost[1] <= Mana[Player] ) {
				Deck$Status[Spell$DeckRow[1]] <- c_CARD_STATUS_GRAVEYARD
				## 関数外の値を更新するので <を２つ入れる。
				Mana[Player] <<- Mana[Player] - Spell$ManaCost[1]
				HP[Opponent] <<- HP[Opponent] - Spell$Power[1]
			}
		}
	
	}
	
	return(Deck)
}

## 対戦相手の生物に呪文を唱える
## DeckRow:呪文を打ち込む対戦相手の生物のDeckRow
## 2021.02.18 CardIdを追加。
MTG_PlaySpell4Creature <- function(Deck, Player, DeckRow, CardId = NULL) {
	## 引数のエラー処理
	if (Deck$Type[DeckRow] != "Creature") { stop("対象のカードがクリーチャーではありません") }

	if (is.null(CardId) ) {
		## カードが指定されない時は、マナコストの低いほうから、対象の生物が破壊できるスペルを探して撃つ。
		Spell <- Deck %>% 
			dplyr::filter(PlayerId == Player, Type == "Instant", Status == c_CARD_STATUS_HAND) %>%
			arrange(ManaCost)
		
		if (nrow(Spell) > 0 & Mana[Player] > 0 ) {
			for (i in 1:nrow(Spell)) {
				if ( Mana[Player] >= Spell$ManaCost[i] & Spell$Power[i] >= Deck$Toughness[DeckRow] & Deck$Status[DeckRow] != c_CARD_STATUS_GRAVEYARD) {
					Deck$Status[Spell$DeckRow[i]] <- c_CARD_STATUS_GRAVEYARD
					Deck$Status[DeckRow] <- c_CARD_STATUS_GRAVEYARD
					## 関数外の値を更新するので <を２つ入れる。
					Mana[Player] <<- Mana[Player] - Spell$ManaCost[i]
					break
				}
			}
		}
	} else {
		## 手札から指定されたカードを探す。
		Spell <- dplyr::filter(Deck, PlayerId == Player, Card == CardId, Status == c_CARD_STATUS_HAND)
		if (nrow(Spell) > 0 & Mana[Player] >= Spell$ManaCost[1] ) {
			## 使用するスペルは１つだけ
			Deck$Status[Spell$DeckRow[1]] <- c_CARD_STATUS_GRAVEYARD
			## 関数外の値を更新するので <を２つ入れる。
			Mana[Player] <<- Mana[Player] - Spell$ManaCost[1]
			if (Spell$Power[1] >= Deck$Toughness[DeckRow] ) {
				Deck$Status[DeckRow] <- c_CARD_STATUS_GRAVEYARD
			} else {
				Deck$Toughness[DeckRow] <- Deck$Toughness[DeckRow] - Spell$Power[1]
			}
		}
	}
	return(Deck)
}

## 対戦相手の場に存在する生物を探す
MTG_SelectTargetCreature <- function(Deck, Player, CardId) {

	Opponent <- MTG_GetOpponent(Player)
	DeckRow <- 0

	## 対戦相手の場に指定されたカードを探す。
	## アンタップ -> 召喚酔い -> タップの順に探す
	OpponentCreature <- dplyr::filter(Deck, PlayerId == Opponent, Card == CardId, Status == c_CARD_STATUS_BA_UNTAP)
	if (nrow(OpponentCreature) > 0 ) {
		DeckRow <- OpponentCreature$DeckRow[1]
	}
	if (DeckRow == 0) {
		OpponentCreature <- dplyr::filter(Deck, PlayerId == Opponent, Card == CardId, Status == c_CARD_STATUS_BA_SS)
		if (nrow(OpponentCreature) > 0 ) {
			DeckRow <- OpponentCreature$DeckRow[1]
		}
	}
	if (DeckRow == 0) {
		OpponentCreature <- dplyr::filter(Deck, PlayerId == Opponent, Card == CardId, Status == c_CARD_STATUS_BA_TAP)
		if (nrow(OpponentCreature) > 0 ) {
			DeckRow <- OpponentCreature$DeckRow[1]
		}
	}
	
	if (DeckRow == 0) { stop("指定されたカードの生物が対戦相手の場に存在しません。") }

	return(DeckRow)
}



## Rで強化学習してみる。

library(ReinforcementLearning)
library(hash)

## マリガンなしで取りあえず強化学習出来るか確認する。
## 学習用の対戦データを作る。
##
##c_DECK_CARD_COUNT = 15
##
## Simple Deck(計算量削減で15枚デッキとする。)
## Deck1: 山 5: 稲妻 10
## Deck2: 森 5: 熊 10

## 各プレイヤーのデッキをデッキに入れる
##MTG_SetDeck <- function(Deck) {
##
##	## プレイヤー１のデッキ
##	Deck$Card[1:5] <- 1
##	Deck$Card[6:15] <- 3
##	## プレイヤー２のデッキ
##	Deck$Card[16:20] <- 2
##	Deck$Card[21:30]<- 4
##	
##	return(Deck)
##}

## 強化学習方針
## 
## 山デッキを強化学習する。
## １アクションごとにState, Action, NextState, Rewardが含まれるData.frameを準備する。
## アクションは、
## 報酬(Reward)は勝利100P、負け0P、引き分け30P、HPを1減らすごとに1Pと定義する。
## 
## 強化学習方針　終わり

## ReinforcementLearningで、使用する学習用データ
##ManaBattery <- data.frame(State = NULL, Action = NULL, NextState = NULL, Reward = NULL)

Q_Mask <- hash()

## ゲームのstate(状態)を作る
MTG_state <- function(Deck, Phase) {
	## 引数のエラー処理
	if (!(Phase %in% c("A", "D", "M")) ) {stop("フェイズの指定が正しくありません")}

	## Deckから必要な列だけ抽出する
	state <- dplyr::select(Deck, PlayerId, Card, Status)

	## 対戦相手の手札
	OpponentHand <- dplyr::filter(Deck, (PlayerId == 2 & Status == c_CARD_STATUS_HAND) )

	## 対戦相手の手札とライブラリはstateから省く
	state <- dplyr::filter(state, (PlayerId == 1 | (PlayerId == 2 & Status %in% c(c_CARD_STATUS_BA_UNTAP, c_CARD_STATUS_BA_TAP, c_CARD_STATUS_BA_SS))) )

	## 並べ替える
	state <- state %>%
		mutate(cs_order = factor(Status, levels = c_CARD_STATUS_ORDER)) %>%
		arrange(cs_order)

	## stateを単なる文字列に変換する。
	state <- stringr::str_c(state$Card, state$Status)
	state <- stringr::str_c(state, collapse = "")

	## フェイズを先頭に、対戦相手の手札枚数を最後に追加する。
	state <- stringr::str_c(Phase, state, sep = "")
	if (nrow(OpponentHand) >0) {
		state <- stringr::str_c(state, "H", sep = "")
		state <- stringr::str_c(state, nrow(OpponentHand), sep = "")
	} else {
		state <- stringr::str_c(state, "H0", sep = "")
	}
	## 使用可能マナ数も最後に追加する。（２マナ以上はまとめる。）
	if (Mana[1] == 0) {
		state <- stringr::str_c(state, "M0", sep = "")
	} else if (Mana[1] == 1) {
		state <- stringr::str_c(state, "M1", sep = "")
	} else {
		state <- stringr::str_c(state, "M2", sep = "")
	}
	
	return (state)
}

## アクションマスクを作る。
MTG_ActionMask <- function(Deck, Phase) {
	## 引数のエラー処理
	if (!(Phase %in% c('A', 'D', 'M')) ) {stop("フェイズの指定が正しくありません")}

	## すべてFALSEで初期化する。
	ActionName <- c('AP', 'A1', 'A2', 'A3', 'DP', 'D1', 'D2', 'D3', 'P', 'M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'M10')
	Mask <- rep(FALSE, c_ACTION_COUNT)
	ActionMask <- as_tibble(data.frame(ActionName, Mask) )

	if (Phase == 'A') {
		## 攻撃フェイズは、攻撃の3アクションのみTRUE
		ActionMask$Mask[1:4] <- TRUE
	} else if (Phase == 'D') {
		## ブロックフェイズは、ブロックの3アクションのみTRUE
		ActionMask$Mask[5:8] <- TRUE
	} else if (Phase == 'M') {
		## パスは常に選択可能
		ActionMask$Mask[9] <- TRUE
		## 手札と、対戦相手の場にいる生物で取れるアクションが変わる。
		Hand <- dplyr::filter(Deck, (PlayerId == 1 & Type != "Land" & Status == c_CARD_STATUS_HAND ) )
		OpponentCreature <- dplyr::filter(Deck, (PlayerId == 2 & Type == "Creature" & Status %in% c(c_CARD_STATUS_BA_UNTAP, c_CARD_STATUS_BA_TAP, c_CARD_STATUS_BA_SS)) )
		if (nrow(OpponentCreature) > 0 ) {
			OpponentCreature <- c(0, OpponentCreature$Card)
		} else {
			OpponentCreature <- c(0)
		}

		MainMask <- rbind(	c(10,  13,  12,  14),
							c(11,  16,  15,  17),
							c(18,NULL,NULL,NULL),
							c(19,NULL,NULL,NULL) )

		col_num <- which(c(0, 4, 8, 9) %in% OpponentCreature)
		row_num <- which(c(3, 7, 5 ,6) %in% Hand$Card)

		action_num <- MainMask[row_num, col_num]
		ActionMask$Mask[action_num] <- TRUE
		if (Mana[1] < 2) {
			## 使用可能マナ数以下のアクションを使用不可にする。
			ActionMask$Mask[17] <- FALSE
		}
	}

	return(ActionMask)
}

## マナバッテリにレコードを追加する。
Urza <- function( state, action, nextState, reward ) {

	if ( exists(ManaBattery) ) {
		ManaBattery <<- rbind(ManaBattery, data.frame(State = state, Action = action, NextState = nextState, Reward = reward) )
	} else {
		ManaBattery <<- data.frame(State = state, Action = action, NextState = nextState, Reward = reward)
	}

	return (TRUE)
}

## ランダムなアクション選択方式
## 2021.02.17 アクションマスクを追加。
MTG_RL_getRandomAction <- function(ActionMask) {
	AvailableAction <- dplyr::filter(ActionMask, Mask==TRUE)
	actionCount <- nrow(AvailableAction)
	n <- as.integer(runif(1, min = 1, max = (1 + actionCount)) )
	return(AvailableAction$ActionName[n])
}

## MentalNoteとほぼ同じだけど、用途が違うので別の名前にしておく。
## method: Random, GreedyGoblin
GoblinLore <- function(method, RandomSeed = 0, flgShowHistory = FALSE) {
	if ( !(method %in% c("Random", "Greedy", "DQN")) ) { stop("アクション決定手段の指定が正しくありません") }

	## デッキを準備する。
	Deck <- MTG_Init()

	## 乱数の元が指定されていたらセットする。（同じ展開になる）
	if (RandomSeed != 0) {
		set.seed(RandomSeed)
	}

	## 初期手札を決める。
	Deck <- MTG_Draw(Deck, 1, 7)
	Deck <- MTG_Draw(Deck, 2, 7)
	
	## ライフとマナの初期値を設定する。
	HP <<- c(20,20)
	Mana <<- c(0, 0)
	
	## 強化学習で使うための変数定義
	lastState <- NULL
	lastAction <- NULL
	reward <- 0
	phase <- 'M'
	flgTurnEnd <- FALSE

	## 先手プレイヤーを決める
	TurnCount = 1
	FirstPlayer = as.integer(runif(1, min = 1, max =3) )
	ActivePlayer = FirstPlayer
	
	## 勝敗が付くまでターンを進める。
	WinPlayer <- MTG_CheckVictory()
	
	## 15枚デッキなので最大で17ターン。それで決着付かなかった場合は引き分け。
	while (WinPlayer == 0 && TurnCount <= ((c_DECK_CARD_COUNT - 7) *2 + 1) ) {

		if (flgShowHistory == TRUE) {
			cat(TurnCount)
			cat("ターン目\n")
		}
		
		## アンタップ、アップキープ
		Deck <- MTG_TurnStart(Deck, ActivePlayer)

		## 先手１ターン目はドローなし
		if (TurnCount > 1) {
			Deck <- MTG_Draw(Deck, ActivePlayer, 1)
		}

		if (ActivePlayer == 1) {
		
			## （可能なら）毎ターン土地はセットする。
			Deck <- MTG_SetLand(Deck, ActivePlayer)
		
			flgTurnEnd = FALSE
			## メインフェイズ
			## 山デッキ側は、指定されたメソッドに応じて手を打つ。
			while (flgTurnEnd == FALSE) {

				phase <- 'M'
				retList <- MTG_RL_getAction(Deck, lastState, lastAction, reward, method, phase, flgShowHistory)
				Deck <- retList[[1]]
				action <- retList[[2]]
				currentState <- retList[[3]]
				
				if (is.null(action) ) { stop("アクションが決定されませんでした。") }
				
				## アクション実施前の状態を保存しておく
				lastAction <- action
				lastState <- currentState
				reward <- 0
				
				switch ( action,
					"P" = {
						## パスアクション（何もしない）
						flgTurnEnd <- TRUE
					},
					"M1" = {
						## 稲妻をプレイヤーに撃つ
						Deck <- MTG_PlaySpell4Opponent(Deck, ActivePlayer, 3)
					},
					"M2" = {
						## ショックをプレイヤーに撃つ
						Deck <- MTG_PlaySpell4Opponent(Deck, ActivePlayer, 7)
					},
					"M3" = {
						## 稲妻を果敢なエルフに撃つ
						DeckRow <- MTG_SelectTargetCreature(Deck, ActivePlayer, 8)
						Deck <- MTG_PlaySpell4Creature(Deck, ActivePlayer, DeckRow, 3)
					},
					"M4" = {
						## 稲妻をシーリアのエルフに撃つ
						DeckRow <- MTG_SelectTargetCreature(Deck, ActivePlayer, 4)
						Deck <- MTG_PlaySpell4Creature(Deck, ActivePlayer, DeckRow, 3)
					},
					"M5" = {
						## 稲妻をケンタウルスの狩猟者に撃つ
						DeckRow <- MTG_SelectTargetCreature(Deck, ActivePlayer, 9)
						Deck <- MTG_PlaySpell4Creature(Deck, ActivePlayer, DeckRow, 3)
					},
					"M6" = {
						## ショックを果敢なエルフに撃つ
						DeckRow <- MTG_SelectTargetCreature(Deck, ActivePlayer, 8)
						Deck <- MTG_PlaySpell4Creature(Deck, ActivePlayer, DeckRow, 7)
					},
					"M7" = {
						## ショックをシーリアのエルフに撃つ
						DeckRow <- MTG_SelectTargetCreature(Deck, ActivePlayer, 4)
						Deck <- MTG_PlaySpell4Creature(Deck, ActivePlayer, DeckRow, 7)
					},
					"M8" = {
						## ショックをケンタウルスの狩猟者に撃つ
						DeckRow <- MTG_SelectTargetCreature(Deck, ActivePlayer, 9)
						Deck <- MTG_PlaySpell4Creature(Deck, ActivePlayer, DeckRow, 7)
					},
					"M9" = {
						## モンスのゴブリン略奪隊を召喚する
						Deck <- MTG_SummonCreature(Deck, ActivePlayer, 5)
					},
					"M10" = {
						## ゴブリンの通り魔を召喚する
						Deck <- MTG_SummonCreature(Deck, ActivePlayer, 6)
					}
				)
				
				## 使用可能マナがないならメインフェイズ終了
				if (Mana[ActivePlayer] == 0) {
					flgTurnEnd <- TRUE
				}
				
				## ターン終了時にアクションが決定されていなかったらパスアクションにする。
				if (flgTurnEnd == TRUE && is.null(lastAction)) {
					lastAction <- "P"
					lastState <- currentState
				}
				if (flgShowHistory == TRUE) {
					cat("flgTurnEnd")
					print(flgTurnEnd)
				}
			}
			
			WinPlayer <- MTG_CheckVictory()
			if (WinPlayer != 0) {
				break
			}

			## 攻撃フェイズ(戻り値はリストで返ってくる。)
			phase <- 'A'
			retList <- MTG_RL_Attack(Deck, ActivePlayer, method, phase, lastAction, lastState, reward, flgShowHistory)
			Deck <- retList[[1]]
			lastAction <- retList[[2]]
			lastState <- retList[[3]]
			reward <- retList[[4]]
			
		} else {
			## 森デッキは、今までと同じ。
			## 第一メインフェイズ
			Deck <- MTG_DoMain(Deck, ActivePlayer, flgShowHistory)
			
			## 攻撃フェイズ
			phase <- 'D'
			retList <- MTG_RL_Attack(Deck, ActivePlayer, method, phase, lastAction, lastState, reward, flgShowHistory)
			Deck <- retList[[1]]
			lastAction <- retList[[2]]
			lastState <- retList[[3]]
			reward <- retList[[4]]
		}
		
		WinPlayer <- MTG_CheckVictory()

		## 終了フェイズ
		Deck <- MTG_TurnEnd(Deck, ActivePlayer)
		
		## コンソールに途中経過を出力する。
		if (flgShowHistory == TRUE) {
			Creature <- dplyr::filter(Deck, Type == "Creature", Status %in% c(c_CARD_STATUS_BA_UNTAP, c_CARD_STATUS_BA_TAP, c_CARD_STATUS_BA_SS))
			if (ActivePlayer == 1) {
				cat("山デッキ（手札）:")
				cat(MTG_Hand(Deck, 1, TRUE))
				cat("\n")
				cat("山デッキ（場）:")
				cat(str_c(dplyr::filter(Creature, PlayerId == 1)$Name, collapse = ","))
				cat("\n")
				cat("森デッキ（場）:")
				cat(str_c(dplyr::filter(Creature, PlayerId == 2)$Name, collapse = ","))
				cat("\n")
			} else {
				cat("森デッキ（手札）:")
				cat(MTG_Hand(Deck, 2, TRUE))
				cat("\n")
				cat("森デッキ（場）:")
				cat(str_c(dplyr::filter(Creature, PlayerId == 2)$Name, collapse = ","))
				cat("\n")
				cat("山デッキ（場）:")
				cat(str_c(dplyr::filter(Creature, PlayerId == 1)$Name, collapse = ","))
				cat("\n")
			}
			print(HP)
			print(Mana)
		}
		
		if (WinPlayer != 0) {
			break
		}
		
		ActivePlayer = MTG_SwitchPlayer(ActivePlayer)
		TurnCount = TurnCount + 1
	}
	
	## 勝敗を判定する。
	if (WinPlayer == 1) {
		LosePlayer = 2
		reward = 100
	} else if (WinPlayer == 2) {
		LosePlayer = 1
		reward = 0
	} else {
		LosePlayer = 0
##		reward = 30
		reward = 0
	}
	
	if (flgShowHistory == TRUE) {
		cat("lastState")
		print(lastState)
		cat("lastAction")
		print(lastAction)
		cat("reward")
		print(reward)
	}
	
	if (method %in% c("Random", "Greedy") ) {
		currentState <- MTG_state(Deck, phase)
		Urza(lastState, lastAction, currentState, reward)
	} else if (method == "DQN") {
		currentState <- MTG_DQN_state(Deck, phase)
		ActionMask <- MTG_ActionMask(Deck, phase)
		Karn(lastState, lastAction, currentState, reward, ActionMask)
	}

	## ゲームを記録して終了。
	if (WinPlayer != 0) {
		GameLog <- data.frame(
			"RandomSeed" = RandomSeed,
			"WinPlayer" = WinPlayer,
			"FirstPlayer" = FirstPlayer,
			"HPWin" = HP[WinPlayer],
			"HPLose" = HP[LosePlayer],
			"finalTurn" = TurnCount
		)
	} else {
		GameLog <- data.frame(
			"RandomSeed" = RandomSeed,
			"WinPlayer" = 0,
			"FirstPlayer" = FirstPlayer,
			"HPWin" = HP[1],
			"HPLose" = HP[2],
			"finalTurn" = TurnCount
		)
	}
	return(GameLog)
}

## 強化学習の機能付きのアタック
## Deck:使用中のDeck
## Player:どちらのプレイヤーが攻撃するか
## method:アクション選択方法
## phase:どのフェイズか(M:メインフェイス、A:アタックフェイス, D:ブロックフェイズ)
## lastAction:直前のアクション
## lastSate:直前のステータス
## reward:AIに渡す報酬
## flgShowHistory:途中経過を表示するか
MTG_RL_Attack <- function(Deck, Player, method, phase, lastAction, lastState, reward, flgShowHistory = FALSE) {

	## 戦場にある攻撃や防御可能な生物カードを取得する。
	Opponent <- MTG_GetOpponent(Player)
	MyCreature <- Deck %>%
		dplyr::filter(PlayerId == Player, Type == "Creature", Status == c_CARD_STATUS_BA_UNTAP) %>%
		arrange(Power)
	OpponentCreature <- Deck %>%
		dplyr::filter(PlayerId == Opponent, Type == "Creature", Status %in% c(c_CARD_STATUS_BA_UNTAP, c_CARD_STATUS_BA_SS) ) %>%
		arrange(desc(Power))

	if (nrow(MyCreature) == 0) {
		## 攻撃クリーチャーがいないなら攻撃終了
		if (flgShowHistory == TRUE) {
			print("skip Attack")
		}
		return(list(Deck, lastAction, lastState, reward))
	}

	if (flgShowHistory == TRUE) {
		cat("Attacker Creature:")
		print(str_c(MyCreature$Name, collapse = ",") )
		if (nrow(OpponentCreature) > 0) {
			cat("Defender Creature:")
			print(str_c(OpponentCreature$Name, collapse = ",") )
		}
	}

	if (Player == 1) {
		## 山デッキは、アクション選択の結果で攻撃する生物を決める。

		retList <- MTG_RL_getAction(Deck, lastState, lastAction, reward, method, phase, flgShowHistory)
		Deck <- retList[[1]]
		action <- retList[[2]]
		currentState <- retList[[3]]

		## アクション実施前の状態を保存しておく
		lastAction <- action
		lastState <- currentState
		reward <- 0

		switch ( action,
			"AP" = {
				## パスアクション（攻撃しない）
				AttackingCreature <- dplyr::filter(MyCreature, Type == "NONE")
			},
			"A1" = {
				## 勝てる生物だけで攻撃
				if (nrow(OpponentCreature) > 0) {
					AttackingCreature <- dplyr::filter(MyCreature, Power > max(OpponentCreature$Toughness) )
				} else {
					AttackingCreature <- MyCreature
				}
			},
			"A2" = {
				## 相打ち出来る生物だけ攻撃
				if (nrow(OpponentCreature) > 0) {
					AttackingCreature <- dplyr::filter(MyCreature, Power >= max(OpponentCreature$Toughness) )
				} else {
					AttackingCreature <- MyCreature
				}
			},
			"A3" = {
				## すべて攻撃
				AttackingCreature <- MyCreature
			}
		)
	} else {
		## 森デッキが、実際に攻撃するのは、防御側プレイヤーの生物と相打ち以上が出来るものだけ
		if (nrow(OpponentCreature) > 0) {
			AttackingCreature <- dplyr::filter(MyCreature, Power >= max(OpponentCreature$Toughness) )
		} else {
			AttackingCreature <- MyCreature
		}
	}

	if (flgShowHistory == TRUE) {
		cat("Attacking Creature:")
		if (nrow(AttackingCreature) > 0) {
			print(str_c(AttackingCreature$Name, collapse = ",") )
		} else {
			cat("none\n")
		}
	}
	
	## 攻撃したクリーチャーをタップ状態にする。
	Deck$Status[Deck$DeckRow %in% AttackingCreature$DeckRow] <- c_CARD_STATUS_BA_TAP

	## ブロック判定
	if (nrow(AttackingCreature) > 0 & nrow(OpponentCreature) > 0) {
		if (Opponent == 1) {
			## 山デッキのブロックは、アクション選択の結果で決める。
		
			retList <- MTG_RL_getAction(Deck, lastState, lastAction, reward, method, phase, flgShowHistory)
			Deck <- retList[[1]]
			action <- retList[[2]]
			currentState <- retList[[3]]
			
			## アクション実施前の状態を保存しておく
			lastAction <- action
			lastState <- currentState
			reward <- 0
		}
		
		## OpponentCreatureのindex
		j <- 1
		
		## 攻撃クリーチャーそれぞれについて
		for (i in 1:nrow(AttackingCreature)) {
			flgHasBlocked <- FALSE
			## まだブロックするクリーチャーが残っている。
			if (j <= nrow(OpponentCreature) ) {
				if (Opponent == 1) {
					## 山デッキのブロックアクション
					switch ( action,
						"DP" = {
							## ブロックしない
						},
						"D1" = {
							## 勝てる生物だけでブロック
							if (AttackingCreature$Power[i] < OpponentCreature$Toughness[j]) {
								flgHasBlocked <- TRUE
							}
						},
						"D2" = {
							## 相打ち出来る生物だけでブロック
							if (AttackingCreature$Power[i] <= OpponentCreature$Toughness[j]) {
								flgHasBlocked <- TRUE
							}
						},,
						"D3" = {
							## 全部ブロック
							flgHasBlocked <- TRUE
						}
					)
				} else {
					## 森デッキは相打ちでもブロックする。
					if (AttackingCreature$Power[i] <= OpponentCreature$Toughness[j]) {
						flgHasBlocked <- TRUE
					}
				}
				if (flgHasBlocked == TRUE) {
					## ブロック成立
					if (AttackingCreature$Power[i] >= OpponentCreature$Toughness[j] ) {
						Deck$Status[OpponentCreature$DeckRow[j]] <- c_CARD_STATUS_GRAVEYARD
					}
					if (OpponentCreature$Power[j] >= AttackingCreature$Toughness[i] ) {
						Deck$Status[AttackingCreature$DeckRow[i]] <- c_CARD_STATUS_GRAVEYARD
						AttackingCreature$Status[i] <- c_CARD_STATUS_GRAVEYARD
					}
					## ブロックしたクリーチャーをプロッククリーチャーから取り除く
					j <- j+1
				}
			}
		}
	}

	## ブロックで死亡したクリーチャーを除外する
	AttackingCreature <- dplyr::filter(AttackingCreature, Status != c_CARD_STATUS_GRAVEYARD)
	
	if (nrow(AttackingCreature) > 0 ) {
	
		if (flgShowHistory == TRUE) {
			cat("Suvived Attacker:")
			print(str_c(AttackingCreature$Name, collapse = ",") )
		}

		## 残ったAttackingCreatureのパワー分だけ相手プレイヤーのHPを減らす
		## 関数外の値を更新するので <を２つ入れる。
		HP[Opponent] <<- HP[Opponent] - sum(AttackingCreature$Power)
		
		if (Player == 1) {
			## 報酬(reward)を直接設定する。
			reward <- reward + sum(AttackingCreature$Power) * 2
		}
	}

	return(list(Deck, lastAction, lastState, reward))
}


## 前回のアクションを記録しつつ、アクションを決定する。
MTG_RL_getAction <- function(Deck, lastState, lastAction, reward, method, phase, flgShowHistory = FALSE) {

	## アクションマスクを求める。
	ActionMask <- MTG_ActionMask(Deck, phase)
	if (method %in% c("Random", "Greedy") ) {
		## 現在の状態(state)を求める。
		currentState <- MTG_state(Deck, phase)
		
		if (is.null(lastAction) == FALSE) {
			## 前回のアクションの結果を記録する。
			Urza(lastState, lastAction, currentState, reward)
		}
		
	} else if ( method == "DQN" ) {
		## DQNでのstateを求める。
		currentState <- MTG_DQN_state(Deck, phase)
		
		if (is.null(lastAction) == FALSE) {
			## 前回のアクションの結果を記録する。
			Karn(lastState, lastAction, currentState, reward, ActionMask)
		}
	}
	
	## アクションを決める。
	if (method == "Random") {
		action <- MTG_RL_getRandomAction(ActionMask)
	} else if (method == "Greedy") {
		## 後でGreedyのアクション選択ロジックを追加する
		action <- MTG_RL_getGreedyAction(currentState, ActionMask)
	} else if ( method == "DQN" ) {
		action <- MTG_DQN_getAction(currentState, ActionMask)
	}
	
	if (flgShowHistory == TRUE) {
		cat("action")
		print(action)
	}

	return(list(Deck, action, currentState) )
}




## 学習した結果に基づくアクションを返す。
## state:
## actionMask:
## global environmentにmodelが作成されていること。
MTG_RL_getGreedyAction <- function(state, ActionMask) {
	
##print(state)
##print(ActionMask)
	
	if ( has.key(state, model$Q_hash) & (runif(1) > control$epsilon) ) {
		## アクションマスク内のQ値が最大のアクションを返す
		actionName <- names(model$Q_hash[[state]])
		maskName <- ActionMask %>% dplyr::filter(Mask == TRUE) %>% select(ActionName)
		
		action <- names(which.max(values(model$Q_hash[[state]])[actionName %in% unlist(maskName)]))
	} else {
		## ランダムにアクションを選ぶ
		action <- MTG_RL_getRandomAction(ActionMask)
	}
	
	return(action)
}

## 学習用モデルを作る
MTG_RL_Init <- function(method) {
	if ( !(method %in% c("GreedyGoblin")) ) { stop("アクション決定手段の指定が正しくありません") }
	
	modelFile <- str_c(workDir, "data/model_random.dat")
	
	if (file.exists(modelFile) ) {
		load(modelFile)
	} else {
		ManaBatteryFile <- str_c(workDir, "data/ManaBattery_random.dat")
		if ( !file.exists(ManaBatteryFile) ) { stop ("学習用のランダムデータが存在しません。") }
		load(ManaBatteryFile)

		## ReinforceLearninパッケージで、Q学習を行う。
		model <<- ReinforcementLearning(ManaBattery, s = "State", a = "Action", r = "Reward", s_new = "NextState", iter = 20, control = control)
	}
	control <<- list(alpha = 0.2, gamma = 0.9, epsilon = 0.1)
	
	return(TRUE)
}



## PowerStoneにレコードを追加する。
Karn <- function( state, action, nextState, reward, ActionMask ) {

	listLength <- 5
	tempList <- vector(mode = "list", length = listLength)
	names(tempList) <- c("state", "action", "nextState", "reward", "ActionMask")
	tempList$state <- state
	## actionは数字に変換する
	tempList$action <- which(ActionMask$ActionName == action)
	tempList$nextState <- nextState
	tempList$reward <- reward
	## ActionMaskは0と1に変更する。
	tempMask <- rep(0, length(ActionMask$Mask))
	tempMask[ActionMask$Mask] <- 1
	tempList$ActionMask <- tempMask
	
	if ( exists("PowerStone") ) {
		PowerStone[[length(PowerStone)+1]] <<- tempList
	} else {
		PowerStone <<- vector(mode = "list", length = 1)
		PowerStone[[1]] <<- tempList
	}

	return (TRUE)
}

## DQNで使用するゲームのstate(状態)を作る
MTG_DQN_state <- function(Deck, Phase) {
	## 引数のエラー処理
	if (!(Phase %in% c("A", "D", "M")) ) {stop("フェイズの指定が正しくありません")}

	## DQNのstateはc_DECK_CARD_COUNT * 2, c_CARD_STATUS_COUNTの2次元配列
	state <- matrix( c(rep(0, c_DECK_CARD_COUNT * 2 * c_CARD_STATUS_COUNT)) , nrow = c_DECK_CARD_COUNT * 2, ncol =c_CARD_STATUS_COUNT )
	
	## デッキのカードステータスと同じところに1を立てる。
	for (i in 1:c_CARD_STATUS_COUNT) {
		state[Deck$Status == c_CARD_STATUS_ORDER[i], i] <-1
	}

	return(state)
}


## DQN環境のセットアップ
## DQNで使用するネットワークや定数をリストとしてGlobalEnvironmentに作成する。
MTG_DQN_Init <- function(method) {
	if ( !(method %in% c("DQN")) ) { stop("アクション決定手段の指定が正しくありません") }
	
	DQN <<-list(NULL, NULL, NULL)
	names(DQN) <<- c('Q_Network', 'TargetNetwork', 'control')

	inputActionMask <- layer_input(shape = c( c_ACTION_COUNT ), name = "ActionMask")
	
	inputState <- layer_input(shape = c( c_DECK_CARD_COUNT * 2, c_CARD_STATUS_COUNT ) , name = "state") 
	
	outputState <- inputState %>%
		layer_flatten() %>%
		layer_dense(units = 32, activation = 'relu', kernel_initializer = 'he_normal') %>%
		layer_dense(units = c_ACTION_COUNT, activation = 'linear', kernel_initializer = 'he_normal')
	
	outputAction <- layer_multiply(inputs = list(outputState, inputActionMask) )
	
	## Q値の代わりとなるDeepNetwork
	DQN$Q_Network <<- keras_model(list(inputActionMask, inputState), outputAction) %>%
		compile( optimizer = 'adam', loss = 'huber', metrics = c('accuracy') )

	outputState_target <- inputState %>%
		layer_flatten() %>%
		layer_dense(units = 32, activation = 'relu', kernel_initializer = 'he_normal') %>%
		layer_dense(units = c_ACTION_COUNT, activation = 'linear', kernel_initializer = 'he_normal')

	outputAction_target <- layer_multiply(inputs = list(outputState_target, inputActionMask) )
	
	## Q_Networkを一時保存しておくTargetNetowrkは、fitで更新しないけど、一応Q_networkと同じ値を入れておく。
	DQN$TargetNetwork <<- keras_model(list(inputActionMask, inputState), outputAction_target) %>%
		compile( optimizer = 'adam', loss = 'huber', metrics = c('accuracy') )
		
	control <- list(
		epsilon = 1.0,
		gamma = 0.9,
		batchSize = 32,
		count = 1
	)
	
	DQN$control <<- control

	return(TRUE)
}

## Pythonのkerasで定義されたhuberロスをRから呼び出すコード
huber <- function(y_true, y_pred) {
  keras$losses$huber(y_true, y_pred)
}
attr(huber, "py_function_name") <- "huber"


## DQNモデルの学習

MTG_DQN_Learn <- function (method) {
	if ( !(method %in% c("DQN")) ) { stop("アクション決定手段の指定が正しくありません") }
	if ( !exists("DQN") ) { stop("DQNモデルが作成されていません。") }
	if ( !exists("PowerStone") ) { stop("学習データ(PowerStone)がありません。") }

	if (DQN$control$count %% 1000 == 0) {
		## Q_NetworkをTargetNetworkにコピー
		keras::set_weights( DQN$TargetNetwork,  keras::get_weights(DQN$Q_Network))
	}
	
	## 学習データからMiniBatch分のデータを取得。
	trainData <- sample(PowerStone, DQN$control$batchSize)

	trainState <- array(sapply(trainData, '[[', 1), dim = c(DQN$control$batchSize, c_DECK_CARD_COUNT * 2, c_CARD_STATUS_COUNT) )
	trainAction <- array(sapply(trainData, '[[', 2), dim = c(DQN$control$batchSize) )
	trainNextState <- array(sapply(trainData, '[[', 3), dim = c(DQN$control$batchSize, c_DECK_CARD_COUNT * 2, c_CARD_STATUS_COUNT) )
	trainReward <- array(sapply(trainData, '[[', 4), dim = c(DQN$control$batchSize) )
	trainActionMask <- array(sapply(trainData, '[[', 5), dim = c(DQN$control$batchSize, c_ACTION_COUNT) )
	
	## reward clipping
	trainReward <- sign(trainReward)
	
	## Q_NetworkからQ値を取得する。
	outQ <- DQN$Q_Network %>% predict( list(state = trainState, ActionMask = trainActionMask), batch_size = DQN$control$batchSize )

	## TargetNetworkから次のステータスのQ値を取得する。
	targetQ <- DQN$TargetNetwork %>% predict( list(state = trainNextState, ActionMask = trainActionMask), batch_size = DQN$control$batchSize )
	
	## 最大のQ値を求める。
	MaxQ <- apply(targetQ, 1, max)

	## Q値を算出する。
	outQ[trainAction] <- trainReward + (MaxQ * DQN$control$gamma)

	## Q_Networkを更新（学習）する
	DQN$Q_Network %>% fit(list(state = trainState, ActionMask = trainActionMask), outQ, epoch = 1, batch_size = DQN$control$batchSize)
	
	DQN$control$count <<- DQN$control$count + 1

	return (TRUE)
}


## DQNの学習と学習結果に基づくアクションを返す。
MTG_DQN_getAction <- function(state, ActionMask) {
	if ( !exists("DQN") ) { stop("DQNモデルが作成されていません。") }

	if ( runif(1) > DQN$control$epsilon ) {
	
		## ActionMaskは0と1に変更する。
		tempMask <- rep(0, length(ActionMask$Mask))
		tempMask[ActionMask$Mask] <- 1

		## Q_NetworkからQ値を求める。
		outQ <- DQN$Q_Network %>% predict( 
			list(
				state = array(state, dim = c(1, c_DECK_CARD_COUNT * 2, c_CARD_STATUS_COUNT)), 
				ActionMask = array(tempMask, dim =c(1, c_ACTION_COUNT))
			), 
			batch_size = 1
		)
		
		## アクションマスク内のQ値が最大のアクションを返す
		mask <- ActionMask %>%
			mutate(Q = outQ[,1]) %>%
			dplyr::filter(Mask == TRUE)
		action <- mask$ActionName[which.max(mask$Q)]

cat(str_c("predict Action:", action, "\n") )

		if ( is.null(action) | is.na(action) ) { stop("正しいアクションが選択されませんでした。") }
	} else {
		## ランダムにアクションを選ぶ
		action <- MTG_RL_getRandomAction(ActionMask)
	}
	
	## データが一定数溜まったら、DeepNetworkの学習を開始する。
	if ( exists("PowerStone") ) {
		if (length(PowerStone) > 32 * 320) {
			MTG_DQN_Learn("DQN")

			## 段々とイプシロンを小さくしていく。
			epsilon <- DQN$control$epsilon
			epsilon <- epsilon - 0.00001
			if (epsilon < 0.01) {
				epsilon <- 0.01
			}
			DQN$control$epsilon <<- epsilon
		}
	}
	
	return(action)
}

## さらに大きな枠組みで、強化学習を行う。
## method:greedy（Q学習のgreedy法）
## loopCount:各学習のループ回数
## iterationCount:反復回数
EfficientConstruction <- function(method, loopCount, iterationCount) {
	if ( !(method %in% c("GreedyGoblin", "DQN")) ) { stop("アクション決定手段の指定が正しくありません") }

	## 学習モデルを作る。	
	if (method == "GreedyGoblin") {
		MTG_RL_Init(method)
	} else if (method == "DQN") {
		MTG_DQN_Init(method)
	}
	
	TotalResult <<- vector(mode = "list", length = iterationCount)
	
	for (i in 1:iterationCount) {
	
		if (method == "GreedyGoblin") {
			if (is.null(model) ) { stop("学習モデルの構築が正常に行われませんでした。") }
			if (i > 1) {
				## 途中の学習元データをファイルに保存する。
				filename <- str_c(workDir, "data/ManaBattery_random_", i, ".dat")
				save(ManaBattery, file = filename)
			}
			## 学習用のデータは、毎回初期化する。
			ManaBattery <<- data.frame(State = NULL, Action = NULL, NextState = NULL, Reward = NULL)

		} else if (method == "DQN") {
			if (is.null(DQN) ) { stop("学習モデルの構築が正常に行われませんでした。") }
			
			if ( exists("PowerStone") ) {
				PSLength <- length(PowerStone)
				if (PSLength >= 100000) {
					PowerStone_back <- PowerStone[[1:20000]]
					PowerStone <<- PowerStone[[20001:PSLength]]
					filename <- str_c(workDir, "data/PowerStone_back_", PSLength, ".dat")
					save(PowerStone_back, filename)
print(filename)
				}
			}
		}
		
		## 千本ノックする
		TotalResult[[i]] <<- AccumulateKnowledge(loopCount, 1, method, FALSE)

		cat(i)
		cat("回目:勝利数")
		cat( sum(TotalResult[[i]]$WinPlayer == 1) )
		cat("\n")
	
		if (i > 1) {
			## 前回の勝利数を下回っていたら、中断
			if (sum(TotalResult[[i]]$WinPlayer == 1) < sum(TotalResult[[i-1]]$WinPlayer == 1) ) {
				break()
			}
		}
		
		if (method == "GreedyGoblin") {
			## ReinforceLearninパッケージで、Q学習を行う。
			## モデルは毎回再構築する。
			model <<- NULL
			model <<- ReinforcementLearning(ManaBattery, s = "State", a = "Action", r = "Reward", s_new = "NextState", iter = 20, control = control)
		} else if (method == "DQN") {
			MTG_DQN_Learn(method)
		}
	
	}
		
	return(TRUE)
}

## Q_Networkの中身を調べるためのコード
Q_Network <- load_model_hdf5(file="c:/yanagawa/R/data/Q_Network.model")

##w <- keras::get_weights(Q_Network)

## 確認用のDeckのstateとActionMaskを作る。
Deck <- MTG_Init()
Deck <- MTG_Draw(Deck, 1, 7)
Deck <- MTG_Draw(Deck, 2, 7)
Deck <- MTG_SetLand(Deck, 1)

phase <- 'M'
ActionMask <- MTG_ActionMask(Deck, phase)
currentState <- MTG_DQN_state(Deck, phase)

## MTG_DQN_getAction内のコードを１行ずつ検証する。
tempMask <- rep(0, length(ActionMask$Mask))
tempMask[ActionMask$Mask] <- 1

outQ <- Q_Network %>% predict( 
	list(
		state = array(currentState, dim = c(1, c_DECK_CARD_COUNT * 2, c_CARD_STATUS_COUNT)), 
		ActionMask = array(tempMask, dim =c(1, c_ACTION_COUNT))
	), 
	batch_size = 1
)
> outQ
           [,1] [,2] [,3] [,4] [,5] [,6] [,7]        [,8]         [,9] [,10] [,11] [,12] [,13]
[1,] 0.07031677    0    0    0    0    0    0 0.001981257 0.0008113208     0     0     0     0
     [,14] [,15]        [,16] [,17]
[1,]     0     0 -0.001168048     0



## 以下は、『RとKerasによるディープラーニング』のP.164からのコードのパクり。

## 全部の値に1を入れたテスト用のstateを用意する
currentState = array(rep(1, c_DECK_CARD_COUNT * 2 * c_CARD_STATUS_COUNT), dim = c(1, c_DECK_CARD_COUNT * 2, c_CARD_STATUS_COUNT))
tempMask = array(rep(1, c_ACTION_COUNT), dim =c(1, c_ACTION_COUNT))

testLayerOutput <- lapply(Q_Network$layers[1:6], function(layer) layer$output)
activationModel <- keras_model(inputs = Q_Network$input, outputs = testLayerOutput)

activations <- activationModel %>% predict( list(state = currentState, ActionMask = tempMask) )








## ２回目以降は保存してあるマナバッテリーを使う。
##load("c:/yanagawa/R/data/ManaBattery_random.dat")
##load("c:/yanagawa/R/data/model_random.dat")


## ReinforceLearninパッケージで、Q学習を行う。
##control <- list(alpha = 0.2, gamma = 0.9, epsilon = 0.1)
##model <- ReinforcementLearning(ManaBattery, s = "State", a = "Action", r = "Reward", s_new = "NextState", iter = 20, control = control)

## 作成した初回のモデルも保存しておく。
##save(model, file="c:/yanagawa/R/data/model_random.dat")

##TotalResult <- list()

##save(TotalResult, file="c:/yanagawa/R/data/TotalResult_EC.dat")

##load("c:/yanagawa/R/data/TotalResult_EC.dat")



## ここから先がテスト用もしくは、説明用のコード


## Deck Init & Draw Test
Deck <- MTG_Init()

Deck <- MTG_Draw(Deck, 1, 7)
Deck <- MTG_Draw(Deck, 2, 7)


## Hand Test
MTG_Hand(Deck, 1)
MTG_Hand(Deck, 2)

MTG_Hand(Deck, 1, TRUE)
MTG_Hand(Deck, 2, TRUE)


## SetLand Test
Deck <- MTG_SetLand(Deck, 1)
MTG_Hand(Deck, 1, TRUE)

## PlaySpell Test
Deck <- MTG_PlaySpell(Deck, 1)
MTG_Hand(Deck, 1, TRUE)

## MentalNote Test
Result <- MentalNote(1, TRUE, FALSE)

## AccumulateKnowledge Test

TotalResult <- AccumulateKnowledge(1000, 1, "MentalNote", FALSE)

save(TotalResult, file="c:/yanagawa/R/data/TotalResult.dat")

load("c:/yanagawa/R/data/TotalResult.dat")

TotalResult_wBlock <- TotalResult
save(TotalResult_wBlock, file="c:/yanagawa/R/data/TotalResult_wBlock.dat")

## 結果を確認してみる。
table(TotalResult$WinPlayer)

  1   2 
832 168 

table(TotalResult$WinPlayer, TotalResult$FirstPlayer)

      1   2
  1 417 415
  2  92  76

table(TotalResult$finalTurn)

SummaryResult <- TotalResult %>%
	group_by(finalTurn, WinPlayer) %>%
	summarize(n = n())

## グラフで表示
ggplot(data = SummaryResult) +
	geom_col(aes(x=finalTurn, y = n, fill = WinPlayer))

## グラフを保存
ggsave("c:/Yanagawa/R/pic/finalTurn.png", width = 30, height = 20, unit = "cm", dpi = 300)



## 処理時間を調べてみる

MentalNote(7, TRUE)
MentalNote(7)


## 5秒かかってるみたい
## 何処を高速化するのが一番効果があるか確認する。

TimeVault <- TimeVault %>%
	mutate(processTime = lubridate::time_length(lubridate::interval(Time, lead(Time),) ) )

TimeVault %>% arrange(desc(processTime) )


## TurnAttackとTurnPlaySpellが遅い
## forループを使っている為なので、それはやめた。
## MTG_Init内でDeckとCardsを一回だけinner_joinするように変更した。



## マリガン(意外と勝敗に関係なかった。あと、乱数固定してあるからマリガン処理入れてもおそらく同じ結果になる。)
TotalResult %>% filter(WinPlayer == 2)

MentalNote(603, TRUE)




## SetCardLibraryTop Test
## テスト用コード
Deck <- MTG_Init()
Deck <- MTG_Draw(Deck, 1, 7)
MTG_Hand(Deck, 1, TRUE)

Deck %>% filter(Status == 1)

Deck <- MTG_SetCardLibraryTop(Deck, 1, 31)
MTG_Hand(Deck, 1, TRUE)

DeckOnTop


## Mulligan Test
set.seed(603)
Deck <- MTG_Init()
Deck <- MTG_Draw(Deck, 1, 7)
MTG_Hand(Deck, 1, TRUE)

Deck <- MTG_Mulligan(Deck, 1, 1, TRUE)

Result <- MentalNote(603, TRUE, TRUE)
Result <- MentalNote(603, TRUE, FALSE)


## GoblinLore Test
Result <- GoblinLore("Random", 1, TRUE)

RandomResult <- AccumulateKnowledge(1000, 1, "GoblinLore")

table(RandomResult$WinPlayer)

   1   2 
 825 175 

## passも３分の１へ変更
  0   1   2 
  4 214 782 

save(ManaBattery, file="c:/yanagawa/R/data/ManaBattery_random.dat")

load("c:/yanagawa/R/data/ManaBattery_random.dat")

table(RandomResult$WinPlayer)


  0   1   2 
194   1 805 

Result <- GoblinLore("Greedy", 1, TRUE)

GreedyResult <- AccumulateKnowledge(1000, 1, "GreedyGoblin")


## これで作成出来た貴重なManaBatteryを利用して強化学習する。

## https://cran.r-project.org/web/packages/ReinforcementLearning/vignettes/ReinforcementLearning.html

# Define reinforcement learning parameters
control <- list(alpha = 0.2, gamma = 0.4, epsilon = 0.1)

# Perform reinforcement learning
model <- ReinforcementLearning(ManaBattery, s = "State", a = "Action", r = "Reward", 
                               s_new = "NextState", iter = 20, control = control)

# Calculate optimal policy
pol <- computePolicy(model)

# Print policy
head(pol)

table(pol)

pol
  L   P   S 
169   9 488 

## passも３分の１へ変更
pol
   L    P    S 
1182  194 1197 

predict(model, data_unseen#state)


## EfficientConstruction Test

EfficientConstruction("GreedyGoblin", 1000, 10)

EfficientConstruction("DQN", 1000, 10)


## DQNのテスト
MTG_DQN_Init("DQN")

summary(DQN$Q_Network)

RandomDQN <- AccumulateKnowledge(100, 1, "DQN")

save(PowerStone, file="c:/yanagawa/R/data/PowerStone_random.dat")
load(file="c:/yanagawa/R/data/PowerStone_random.dat")

Result <- GoblinLore("DQN", 1, TRUE)

options(warn =2)


## MTG_DQN_Learn Test
MTG_DQN_Learn("DQN")



save_model_hdf5(DQN$Q_Network, file="c:/yanagawa/R/data/Q_Network.model")
save_model_hdf5(DQN$TargetNetwork, file="c:/yanagawa/R/data/TargetNetwork.model")



