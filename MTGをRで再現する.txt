## RでMagic:the Gatheringのゲームを再現する試み

library(tidymodels)
library(tidyverse)


## 定数定義
c_DECK_CARD_COUNT <- 60 ## 各デッキの枚数


## Simple Deck
## Deck1: 山 20: 稲妻 40
## Deck2: 森 20: 熊 40

## 配列の定義
## 両プレイヤーのデッキ。とりあえず60枚固定。
## Cardがカードの種類
## Statusがカードの状態(0:ライブラリ, 1:手札, 2:場, 3:墓地, 4:除外)
## 202012.23 DeckRowを追加
Deck <- tibble(
	DeckRow = c(1:(c_DECK_CARD_COUNT * 2)),
	PlayerId = c(rep(1, c_DECK_CARD_COUNT), rep(2, c_DECK_CARD_COUNT)),
	Card = c(rep(0, (c_DECK_CARD_COUNT * 2))),
	Status = c(rep(0, (c_DECK_CARD_COUNT * 2)))
)

## HPとマナ
HP <- c(20,20)
Mana <- c(0, 0)


## カード定義（そのうち外部ファイルにする）
Cards <- tibble(
	Id = c(1, 2, 101, 102),
	Name = c("山", "森", "稲妻", "熊"),
	Type = c("Land", "Land", "Instant", "Creature"),
	ManaCost = c(0, 0, 1, 2),
	Power = c(0, 0, 3, 2),
	Toughness = c(0, 0, 0, 2)
)

## ライブラリの上と下の位置が分っているカードを保持する。
DeckOnTop <- list(list(), list())
DeckOnBottom <- list(list(), list())

## デッキを準備する
## 2020.12.23 高速化 (カードマスタのとinner_joinを１回だけにした)
## 2020.12.23 DeckOnTopとDeckOnBottomの初期化を追加。
## 2021.01.25 デッキ枚数を可変にした。
MTG_Init <- function() {

	Deck <- tibble(
		DeckRow = c(1:(c_DECK_CARD_COUNT * 2)),
		PlayerId = c(rep(1, c_DECK_CARD_COUNT), rep(2, c_DECK_CARD_COUNT)),
		Card = c(rep(0, (c_DECK_CARD_COUNT * 2))),
		Status = c(rep(0, (c_DECK_CARD_COUNT * 2)))
	)
	## すべてのカードをライブラリへおく
	Deck$Status <- 0
	
	## 各プレイヤーのデッキを設定する。
	Deck <- MTG_SetDeck(Deck)
	
	## カードマスタとのinner_joinはここで１回だけやればいい
	Deck <- Deck %>% inner_join(Cards, by = c("Card" = "Id") )

	## ライブラリの上と下の位置が分っているカードのリストを空にする。
	DeckOnTop <<- list(list(), list())
	DeckOnBottom <<- list(list(), list())

	return(Deck)
}

## 各プレイヤーのデッキをデッキに入れる
MTG_SetDeck <- function(Deck) {

	## プレイヤー１のデッキ
	Deck$Card[1:20] <- 1
	Deck$Card[21:60] <- 101
	## プレイヤー２のデッキ
	Deck$Card[61:80] <- 2
	Deck$Card[81:120]<- 102
	
	return(Deck)
}

## MTG_Draw関数 ライブラリーからカードを引く
## Deck:使用中のDeck
## Player:どちらのプレイヤーのライブラリから引くか
## CardCount:引くカードの枚数
## 2020.12.25 ライブラリの上から引く処理とライブラリの底のカードを引かない処理を追加
## 2021.01.25 デッキ枚数を可変にした。
MTG_Draw <- function(Deck, Player, CardCount) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (CardCount < 1 & CardCount > c_DECK_CARD_COUNT) { stop("引くカード枚数の指定が正しくありません") }

	drawCard = 0
	## DeckOnTopにカードがあったらそこから引く
	tempList <- DeckOnTop[[Player]]
	if (length(tempList) > 0) {
		while (drawCard < CardCount && length(tempList) > 0) {
			tempRow = tempList[ length(tempList) ]
			Deck$Status[tempRow] <- 1
			tempList[ length(tempList) ] <- NULL
			drawCard <- drawCard + 1
		}
		DeckOnTop[[Player]] <<- tempList
	}
	
	## ライブラリからランダムに１枚選ぶ
	while (drawCard < CardCount) {
		## お試しロジックなので、おバカコード
		n = as.integer(runif(1, min = 1, max = (c_DECK_CARD_COUNT + 1)) )
		if (Player == 2) { n = n + c_DECK_CARD_COUNT }
		if (Deck$Status[n] == 0 & MTG_CheckCardLibraryBottom(Player, n) == 0) { 
			Deck$Status[n] <- 1
			drawCard = drawCard + 1
		}
	}
	return(Deck)
}

## 対象プレイヤーの手札を確認する。
## Deck:使用中のDeck
## Player:どちらのプレイヤーのハンドを確認するか
MTG_Hand <- function(Deck, Player, flgShowCardName = FALSE) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }

	Hand <- Deck %>% filter(PlayerId == Player & Status == 1)
	
	if ( flgShowCardName) {
		if (nrow(Hand) > 0 ) {
			for(i in 1:nrow(Hand) ) {
				if (i == 1) {
					handStr = Hand$Name[i]
				} else {
					handStr <- paste( handStr, Hand$Name[i], sep = ",")
				}
			}
		} else {
			handStr = "(None)"
		}
		return(handStr)
	} else {
		return(Hand$Card)
	}
}

## 土地を置く
## Deck:使用中のDeck
## Player:どちらのプレイヤーの土地をおくか
## 2020.12.23 高速化（forループを使用しないようにした。）
MTG_SetLand <- function(Deck, Player) {

	## 対象プレイヤーの手札の土地カードを取得する。
	HandLand <- Deck %>% 
		filter(PlayerId == Player & Status == 1 & Type == "Land")

	if (nrow(HandLand) > 0 ) {
		## 1枚だけ土地を戦場に出す
		Deck$Status[HandLand$DeckRow[1]] <- 2
		## 関数外の値を更新するので <を２つ入れる。
		Mana[Player] <<- Mana[Player] + 1
	}
	return(Deck)
}

## スペルを使う
## Deck:使用中のDeck
## Player:どちらのプレイヤーがスペルを使うか
## 2020.12.23 高速化（だけどここだけはforループを使わざるを得ない）
MTG_PlaySpell <- function(Deck, Player) {

	## 対象プレイヤーの手札にInstantかCreatureがあるか？
	Hand <- Deck %>% 
		filter(PlayerId == Player & Status == 1 & (Type == "Instant" | Type == "Creature") )

	if (nrow(Hand) > 0 ) {
		for(i in 1:nrow(Hand) ) {
			if ( Hand$ManaCost[i] <= Mana[Player] ) {
				if (Hand$Type[i] == "Instant") {
					## Instantがあった
					Opponent = 3 - Player
					Deck$Status[Hand$DeckRow[i]] <- 3
					## 関数外の値を更新するので <を２つ入れる。
					HP[Opponent] <<- HP[Opponent] - Hand$Power[i]
					Mana[Player] <<- Mana[Player] - Hand$ManaCost[i]
				} else if (Hand$Type[i] == "Creature") {
					## Creature呪文があった
					Deck$Status[Hand$DeckRow[i]] <- 2
					## 関数外の値を更新するので <を２つ入れる。
					Mana[Player] <<- Mana[Player] - Hand$ManaCost[i]
				}
			}
		}
	}
	return(Deck)
}


## アタック
## Deck:使用中のDeck
## Player:どちらのプレイヤーが攻撃するか
## 2020.12.23 高速化（forループを使用しないようにした。）
MTG_Attack <- function(Deck, Player) {

	## 対象プレイヤーの戦場にある生物カードと取得する。
	BattleFieldCreature <- Deck %>% 
		filter(PlayerId == Player & Status == 2 & Type == "Creature")
	
	if (nrow(BattleFieldCreature) > 0) {
		## 場にいるCreatureのパワー分だけ相手プレイヤーのHPを減らす
		Opponent = 3 - Player
		## 関数外の値を更新するので <を２つ入れる。
		HP[Opponent] <<- HP[Opponent] - sum(BattleFieldCreature$Power)
	}

	return(Deck)
}

## ターン開始時の処理など
## 今は、マナを入れる処理だけ
## Deck:使用中のDeck
## Player:どちらのプレイヤーの開始処理か
MTG_TurnStart <- function(Deck, Player) {

	BattleFieldLand <- Deck %>% filter(PlayerId == Player & Status == 2 & Type == "Land")
	
	Mana[Player] <<- nrow(BattleFieldLand)

	## 返す必要ないがお約束なので入れておく。
	return(Deck)
}

## ターン終了時の処理など
## 今はDiscardの処理だけ
## Deck:使用中のDeck
## Player:どちらのプレイヤーのターン終了時の処理か
## 2021.01.26 高速化ロジックで統一
MTG_TurnEnd <- function(Deck, Player) {

	Hand <- Deck %>% filter(PlayerId == Player & Status == 1)

	CardCount <- nrow(Hand)
	while (CardCount > 7) {
		n = as.integer(runif(1, min = 1, max = CardCount + 1) )
		Deck$Status[Hand$DeckRow[n]] <- 3
		CardCount = CardCount - 1
	}

	return(Deck)
}

## 手番プレイヤーを交代する。
## ActivePlayer:現在の手番プレイヤー
MTG_SwitchPlayer <- function(ActivePlayer) {
	
	NextPlayer <- 1
	if (ActivePlayer == 1) {
		NextPlayer <- 2
	}
	return(NextPlayer)
}

## 勝利条件の判定をする
MTG_CheckVictory <- function() {

	WinPlayer = 0
	if (HP[1] <= 0) {
		WinPlayer = 2
	} else if (HP[2] <= 0 ) {
		WinPlayer = 1
	}
	return (WinPlayer)
}



## 高速化の時間測定用

## まずは、どの処理にどれだけ時間が掛かっているか分らないと高速化しようがないので、時間を計ります。
## なんか思っていたようなPackageがなかったので、これも自作します。（tictocは、よさげでした）
TimeVault <- as_tibble( data.frame(processName=character(), Time= as.Date(character()) ) )
Teferi <- function(ProcessName) {
	if (ProcessName == "Init") {
		TimeVault <<- as_tibble( data.frame(processName=character(), Time= as.Date(character()) ) )
	}
	TimeVault <<- rbind(TimeVault, data.frame(ProcessName, Time = Sys.time()) )
}


## Logをどうするか考える。
## 名称はGameLog で、DataFrame
## RandomSeed
## 勝利プレイヤー
## 先手プレイヤー
## HPWin
## HPLose
## TurnCount

## GameHistory## は同じRandomSeedを渡すことで再現できる

## ゲームを進行させる。
## RandomSeed:乱数の元（デフォルトは0で指定しない）
## flgShowHistory:対戦経過をConsoleへ出力するか
## 2020.12.22 処理時間を計る処理を追加
## 2020.12.25 マリガンをする／しないを追加
MentalNote <- function(RandomSeed = 0, flgShowHistory = FALSE, flgDoMulligan = TRUE) {

##Teferi("Init")

	## デッキを準備する。
	Deck <- MTG_Init()

##Teferi("SetRandomSeed")

	## 乱数の元が指定されていたらセットする。（同じ展開になる）
	if (RandomSeed != 0) {
		set.seed(RandomSeed)
	}

##Teferi("DrawInitialHand")

	## 初期手札を決める。
	Deck <- MTG_Draw(Deck, 1, 7)
	Deck <- MTG_Draw(Deck, 2, 7)
	
	## ライフとマナの初期値を設定する。
	HP <<- c(20,20)
	Mana <<- c(0, 0)

##Teferi("DecideFirstPlayer")

	## 先手プレイヤーを決める
	TurnCount = 1
	FirstPlayer = as.integer(runif(1, min = 1, max =3) )
	ActivePlayer = FirstPlayer
	
	if (flgDoMulligan == TRUE) {
		## 先手側マリガン処理
		Deck <- MTG_Mulligan(Deck, ActivePlayer, FirstPlayer, flgShowHistory)
		## 後手側マリガン処理
		Deck <- MTG_Mulligan(Deck, 3-ActivePlayer, FirstPlayer, flgShowHistory)
	}		
	
	## 勝敗が付くまでターンを進める。
	WinPlayer <- MTG_CheckVictory()
	while (WinPlayer == 0) {

##Teferi("TurnStart")

		## アンタップ、アップキープ
		Deck <<- MTG_TurnStart(Deck, ActivePlayer)

##Teferi("TurnDraw")

		## 先手１ターン目はドローなし
		if (TurnCount > 1) {
			Deck <- MTG_Draw(Deck, ActivePlayer, 1)
		}

##Teferi("TurnSetLand")

		## 第一メインフェイズに土地を置く
		Deck <- MTG_SetLand(Deck, ActivePlayer)
		
##Teferi("TurnAttack")

		## 攻撃フェイズ
		Deck <- MTG_Attack(Deck, ActivePlayer)

##Teferi("TurnPlaySpell")

		## 第二メインフェイズ
		Deck <- MTG_PlaySpell(Deck, ActivePlayer)
		
##Teferi("TurnCheckVictory")

		WinPlayer <- MTG_CheckVictory()

##Teferi("TurnEnd")

		## 終了フェイズ
		Deck <- MTG_TurnEnd(Deck, ActivePlayer)
		
##Teferi("TurnShowHistory")

		## コンソールに途中経過を出力する。
		if (flgShowHistory == TRUE) {
			cat(TurnCount)
			cat("ターン目\n")
			if (ActivePlayer == 1) {
				cat("山デッキ:")
				cat(MTG_Hand(Deck, 1, TRUE))
				cat("\n")
			} else {
				cat("森デッキ:")
				cat(MTG_Hand(Deck, 2, TRUE))
				cat("\n")
			}
			print(HP)
			print(Mana)
		}
		
		if (WinPlayer != 0) {
			break
		}
		
		ActivePlayer = MTG_SwitchPlayer(ActivePlayer)
		TurnCount = TurnCount + 1
	}
	
	## ゲームを記録して終了。
	LosePlayer = 1
	if (WinPlayer == 1) {
		LosePlayer = 2
	}
	
	GameLog <- data.frame(
		"RandomSeed" = RandomSeed,
		"WinPlayer" = WinPlayer,
		"FirstPlayer" = FirstPlayer,
		"HPWin" = HP[WinPlayer],
		"HPLose" = HP[LosePlayer],
		"finalTurn" = TurnCount
	)
	return(GameLog)
}

##Result <- MentalNote()

## 最後にｎ回シミュレートさせる関数を作る。
## LoopCount:試行回数
## StartSeed:乱数の元の開始番号
## 2021.01.26 runMethodを追加:シミュレートさせる関数名
AccumulateKnowledge <- function(LoopCount, StartSeed, runMethod = "MentalNote", flgDoMulligan = TRUE) {
	## 引数のエラー処理
	if (LoopCount < 1) { stop("試行回数は1以上を指定してください。") }

	StartTime = Sys.time()
	print(StartTime)
	for(i in 1:LoopCount) {
		print(i)
		if (runMethod == "MetalNote") {
			Result <- MentalNote(StartSeed + i - 1, FALSE, flgDoMulligan)
		} else if (runMethod == "GoblinLore") {
			Result <- GoblinLore("Random", StartSeed + i - 1, FALSE)
		}
		if ( i == 1 ) {
			TotalResult <- Result
		} else {
			TotalResult <- rbind(TotalResult, Result)
		}
	}
	EndTime = Sys.time()
	print(EndTime)
	print(EndTime - StartTime)
	
	return(TotalResult)
}



## ロンドンマリガンで、毎回7枚引いて、マリガン回数分のカードを山札の最後に戻す。

## さて、ここで山札の底のカードや上のカードの処理を先に作ります。
## 当然ドローの処理も変更になるので、あわせて修正します。

## 実装方法はいくつか考えられますが、MTGではあまり、ライブラリの順番が分っていることは少ないので、いつものようにリストで表現します。
## DeckOnTopとDeckOnBottomがそれぞれ、ライブラリの上のカードと底のカードを表していて、このリストがNULLのときは、分っているときはない状態です。
## 上からどんどんカードを置いていって、ドローするときには上のカードを引くのでLILO（Last in Last out)です。
##DeckOnTop <- list(list(), list())
##DeckOnBottom <- list(list(), list())

## 指定したDeckRowのカードがLibraryTopにあるか確認する。
## flgIsRemoveCard:指定したDeckRowのカードをLibraryTopから削除する。
## 戻り値:指定したカードがあるならDeckRowが、ないなら0を返す。
MTG_CheckCardLibraryTop <- function(Player, DeckRow, flgIsRemoveCard = FALSE) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (Player == 1 & ( DeckRow < 1 | DeckRow > c_DECK_CARD_COUNT) ) { stop("カードの指定が正しくありません") }
	if (Player == 2 & ( DeckRow < c_DECK_CARD_COUNT | DeckRow > (c_DECK_CARD_COUNT * 2)) ) { stop("カードの指定が正しくありません") }
	
	tempRow <- list()
	tempList <- DeckOnTop[[Player]]
	if (length(tempList) > 0) {
		tempRow <- tempList[tempList == DeckRow]
		if (length(tempRow) > 0 ) {
			if (tempRow == DeckRow & flgIsRemoveCard) {
				tempList[tempList == DeckRow] <- NULL
				DeckOnTop[[Player]] <<- tempList
			}
		}
	}
	if (length(tempRow) == 0) {
		return( 0 )
	} else {
		return( DeckRow )
	}
}

## 指定したDeckRowのカードがLibraryBottomにあるか確認する。
## flgIsRemoveCard:指定したDeckRowのカードをLibraryBottomから削除する。
## 戻り値:指定したカードがあるならDeckRowが、ないなら0を返す。
MTG_CheckCardLibraryBottom <- function(Player, DeckRow, flgIsRemoveCard = FALSE) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (Player == 1 & ( DeckRow < 1 | DeckRow > c_DECK_CARD_COUNT) ) { stop("カードの指定が正しくありません") }
	if (Player == 2 & ( DeckRow < c_DECK_CARD_COUNT | DeckRow > (c_DECK_CARD_COUNT * 2)) ) { stop("カードの指定が正しくありません") }
	
	tempRow <- list()
	tempList <- DeckOnBottom[[Player]]
	if (length(tempList) > 0) {
		tempRow <- tempList[tempList == DeckRow]
		if (length(tempRow) > 0 ) {
			if (tempRow == DeckRow & flgIsRemoveCard) {
				tempList[tempList == DeckRow] <- NULL
				DeckOnBottom[[Player]] <<- tempList
			}
		}
	}
	if (length(tempRow) == 0) {
		return( 0 )
	} else {
		return( DeckRow )
	}
}

## DeckRowのカードをライブラリの上に乗せる。
MTG_SetCardLibraryTop <- function(Deck, Player, DeckRow) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (Player == 1 & ( DeckRow < 1 | DeckRow > c_DECK_CARD_COUNT) ) { stop("カードの指定が正しくありません") }
	if (Player == 2 & ( DeckRow < c_DECK_CARD_COUNT | DeckRow > (c_DECK_CARD_COUNT * 2)) ) { stop("カードの指定が正しくありません") }
	
	## 指定されたカードが既にライブラリの上や底にあったら削除する。
	tempRow <- MTG_CheckCardLibraryTop(Player, DeckRow, TRUE)
	tempRow <- MTG_CheckCardLibraryBottom(Player, DeckRow, TRUE)
	
	tempList <- DeckOnTop[[Player]]
	if (length(tempList) > 0) {
		tempList[length(tempList)+1] <- DeckRow
	} else {
		tempList[1] <- DeckRow
	}
	DeckOnTop[[Player]] <<- tempList
	Deck$Status[DeckRow] <- 0
	
	return(Deck)
}

## DeckRowのカードをライブラリの底に入れる。。
MTG_SetCardLibraryBottom <- function(Deck, Player, DeckRow) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (Player == 1 & ( DeckRow < 1 | DeckRow > c_DECK_CARD_COUNT) ) { stop("カードの指定が正しくありません") }
	if (Player == 2 & ( DeckRow < c_DECK_CARD_COUNT | DeckRow > (c_DECK_CARD_COUNT * 2)) ) { stop("カードの指定が正しくありません") }
	
	## 指定されたカードが既にライブラリの上や底にあったら削除する。
	tempRow <- MTG_CheckCardLibraryTop(Player, DeckRow, TRUE)
	tempRow <- MTG_CheckCardLibraryBottom(Player, DeckRow, TRUE)
	
	tempList <- DeckOnBottom[[Player]]
	if (length(tempList) > 0) {
		tempList[length(tempList)+1] <- DeckRow
	} else {
		tempList[1] <- DeckRow
	}
	DeckOnBottom[[Player]] <<- tempList
	Deck$Status[DeckRow] <- 0
	
	return(Deck)
}


## マリガン処理（ロンドンマリガン、7枚引いてマリガン回数分のカードをライブラリの底に置く）
## マリガン判定のルール（私が、勝手に決めた）
## 手札が4枚になるまではマリガンする。
## 土地が1枚もないか、土地が4枚以上ならマリガン
## 土地1枚は、先行なら手札が7枚の時はマリガン、後攻ならマリガンしない。

## Player:どちらのプレイヤーのマリガンの処理か
## FirstPlayer:最初にプレイするプレイヤー
## flgShowHistory:対戦経過をConsoleへ出力するか
MTG_Mulligan <- function(Deck, Player, FirstPlayer, flgShowHistory) {
	## 引数のエラー処理
	if (Player < 1 & Player > 2) { stop("プレイヤの指定が正しくありません") }
	if (FirstPlayer < 1 & FirstPlayer > 2) { stop("先手プレイヤの指定が正しくありません") }

	MulliganCount <- 0
	while (MulliganCount < 3) {
		LandCards <- Deck %>% filter(PlayerId == Player & Status == 1 & Type == "Land")
	
		if (nrow(LandCards) > 1 & nrow(LandCards) < 5) {
			## 土地が2枚から4枚はマリガンしない
			break
		} else if (nrow(LandCards) == 1) {
			## 土地1枚は、後手か、先手の手札6枚以下ならマリガンしない
			if (Player != FirstPlayer | MulliganCount > 0) {
				break
			}
		}
		## ここまで来たら、マリガンします。マリガン前の手札を表示しておく
		if (flgShowHistory == TRUE) {
			cat("Mulligan ")
			print(MulliganCount)
			print(MTG_Hand(Deck, Player, TRUE) )
		}
		## 手札のカードをライブラリに戻す。
		Deck$Status[Deck$PlayerId == Player] <- 0
		#Hand <- Deck %>% filter(PlayerId == Player & Status == 1)
		#Deck$Status[Deck$DeckRow %in% Hand$DeckRow] <- 0

		## 新しい手札を引く
		Deck <- MTG_Draw(Deck, Player, 7)
		
		MulliganCount <- MulliganCount + 1
	}
	
	if (MulliganCount > 0) {
		## 1回以上マリガンしたら、手札をマリガン回数枚ライブラリの底に置く
		while( MulliganCount > 0 ) {
			## 土地が3枚以上なら土地を置く
			LandCards <- Deck %>% filter(PlayerId == Player & Status == 1 & Type == "Land")
			if (nrow(LandCards) > 2) {
				tempRow <- LandCards$DeckRow[1]
			} else {
				NotLandCards <- Deck %>% filter(PlayerId == Player & Status == 1 & Type != "Land")
				tempRow <- NotLandCards$DeckRow[1]
			}
			Deck <- MTG_SetCardLibraryBottom(Deck, Player, tempRow)
		
			MulliganCount <- MulliganCount - 1
		}
		## マリガン後の手札を表示しておく
		if (flgShowHistory == TRUE) {
			print("After Mulligan")
			print(MTG_Hand(Deck, Player, TRUE) )
		}
		
	}

	return(Deck)
}


## Rで強化学習してみる。

library(ReinforcementLearning)

## マリガンなしで取りあえず強化学習出来るか確認する。
## 学習用の対戦データを作る。

c_DECK_CARD_COUNT = 15

## Simple Deck(計算量削減で15枚デッキとする。)
## Deck1: 山 5: 稲妻 10
## Deck2: 森 5: 熊 10

## 各プレイヤーのデッキをデッキに入れる
MTG_SetDeck <- function(Deck) {

	## プレイヤー１のデッキ
	Deck$Card[1:5] <- 1
	Deck$Card[6:15] <- 101
	## プレイヤー２のデッキ
	Deck$Card[16:20] <- 2
	Deck$Card[21:30]<- 102
	
	return(Deck)
}

## 強化学習方針
## 
## 山デッキを強化学習する。
## １アクションごとにState, Action, NextState, Rewardが含まれるData.frameを準備する。
## アクションは、
## ・土地をセット
## ・スペルを使う
## の2つだけ。
## 状態(State)はDeckを渡すと、文字列を返す関数を作る。
## またDeckのDeckRowや後半部分のCardの内容は必要ない。
## 報酬(Reward)は勝利100P、負け0P、引き分け30P、HPを1減らすごとに1Pと定義する。
## 
## 強化学習方針　終わり

## ReinforcementLearningで、使用する学習用データ
ManaBattery <- data.frame(State = NULL, Action = NULL, NextState = NULL, Reward = NULL)

## ManaBatteryにデータを書き込む
Urza <- function( state, action, nextState, reward ) {

	ManaBattery <- data.frame(State = state, Action = action, NextState = nextState, Reward = reward)

	return (ManaBattery)
}

## ゲームの状態は取りあえず、Deckだけ使って見る。
MTG_state <- function(Deck) {

	## Deckから必要な列だけ抽出する
	state <- dplyr::select(Deck, Card, Status)
	## 手札、場、墓地、ライブラリの順番に並び替える。
	## そのためライブラリのコードを一旦最後に持っていく。
	state$Status[state$Status == 0] <- 4
	
	state <- dplyr::arrange(state, Status, Card)
	
	state$Card[state$Card == 1] <- "M"
	state$Card[state$Card == 2] <- "F"
	state$Card[state$Card == 101] <- "L"
	state$Card[state$Card == 102] <- "B"

	state$Status[state$Status == 1] <- "h"
	state$Status[state$Status == 2] <- "b"
	state$Status[state$Status == 3] <- "g"
	state$Status[state$Status == 4] <- "d"

	state <- stringr::str_c(state$Card, state$Status)
	state <- stringr::str_c(state, collapse = "")
	return (state)
}


## ランダムなアクション選択方式
MTG_getRandomAction <- function(TurnCount) {
	action <- NULL
	while (is.null(action) == TRUE) {
		n <- as.integer(runif(1, min = 1, max = 4) )
		if (n == 1) {
			## パスアクション（けど１ターン目からパスされると盤面進まないのではじめのころは選ばれづらくする）
			if ( as.integer( (TurnCount + 1)/ 2) > as.integer(runif(1, min = 1, max = 10)) ) {
				action <- "P"
			} 
		} else if (n == 2) {
			## 土地を置くアクション
			action <- "L"
		} else if (n == 3) {
			## スペルを使うアクション
			action <- "S"
		}
	}
	return(action)
}

## MentalNoteとほぼ同じだけど、用途が違うので別の名前にしておく。
## method: Random, Greedy
GoblinLore <- function(method, RandomSeed = 0, flgShowHistory = FALSE) {
	if (method %in% c("Random", "Greedy") == FALSE) { stop("アクション決定手段の指定が正しくありません") }

	## デッキを準備する。
	Deck <- MTG_Init()

	## 乱数の元が指定されていたらセットする。（同じ展開になる）
	if (RandomSeed != 0) {
		set.seed(RandomSeed)
	}

	## 初期手札を決める。
	Deck <- MTG_Draw(Deck, 1, 7)
	Deck <- MTG_Draw(Deck, 2, 7)
	
	## ライフとマナの初期値を設定する。
	HP <<- c(20,20)
	Mana <<- c(0, 0)
	
	## 強化学習で使うための変数定義
	last_state <- NULL
	last_action <- NULL
	last_HP <- HP[2]
	flgIsSetLand <- FALSE
	flgTurnEnd <- FALSE

	## 先手プレイヤーを決める
	TurnCount = 1
	FirstPlayer = as.integer(runif(1, min = 1, max =3) )
	ActivePlayer = FirstPlayer
	
	## 勝敗が付くまでターンを進める。
	WinPlayer <- MTG_CheckVictory()
	
	## 15枚デッキなので最大で17ターン。それで決着付かなかった場合は引き分け。
	while (WinPlayer == 0 && TurnCount <= 17) {

		## アンタップ、アップキープ
		Deck <<- MTG_TurnStart(Deck, ActivePlayer)

		## 先手１ターン目はドローなし
		if (TurnCount > 1) {
			Deck <- MTG_Draw(Deck, ActivePlayer, 1)
		}

		if (ActivePlayer == 1) {
			flgTurnEnd = FALSE
			## 山デッキ側は、指定されたメソッドに応じて手を打つ。
			while (flgTurnEnd == FALSE) {
				if (is.null(last_action) == FALSE) {
					## 前回のアクションの結果を記録する。
					reward <- last_HP - HP[2]
					if (nrow(ManaBattery) > 0) {
						ManaBattery <<- rbind(ManaBattery, Urza(last_state, last_action, MTG_state(Deck), reward) )
					} else {
						ManaBattery <<- Urza(last_state, last_action, MTG_state(Deck), reward)
					}
					last_action <- NULL
				}
				
				## アクションを決める。
				if (method == "Random") {
					action <- MTG_getRandomAction(TurnCount)
				} else if (method == "Greedy") {
					## 後でGreedyのアクション選択ロジックを追加する
					action <- MTG_getGreedyAction(MTG_state(Deck))
				} else {
				}
				
				## 決めたアクションが実行可能か
				if (action == "P") {
					## パスアクション（何もしない）
					last_action <- action
					last_HP <- HP[2]
					last_state <- MTG_state(Deck)
					flgTurnEnd <- TRUE
				} else if (action == "L") {
					## 土地を置くアクション
					if (flgIsSetLand == FALSE) {
						last_action <- action
						last_HP <- HP[2]
						last_state <- MTG_state(Deck)
						Deck <- MTG_SetLand(Deck, ActivePlayer)
						flgIsSetLand <- TRUE
					}
				} else if (action == "S") {
					## スペルを使うアクション
					if (Mana[1] > 0) {
						last_action <- action
						last_HP <- HP[2]
						last_state <- MTG_state(Deck)
						Deck <- MTG_PlaySpell(Deck, ActivePlayer)
					}
				}
				
				## 手札に土地がなければセットランド済みとする
				if (nrow(dplyr::filter(Deck, PlayerId == 1 & Status == 1 & Type == "Land")) == 0) {
					flgIsSetLand <- TRUE
				}
				
				## 土地をセットして、使用可能マナがないならTurn終了
				if (flgIsSetLand == TRUE & Mana[1] == 0) {
					flgTurnEnd <- TRUE
				}
				## 土地をセットして、手札に土地以外がないならTurn終了
				if (flgIsSetLand == TRUE && nrow(dplyr::filter(Deck, PlayerId == 1 & Status == 1 & Type != "Land")) == 0 ) {
					flgTurnEnd <- TRUE
				}
				## ターン終了時にアクションが決定されていなかったらパスアクションにする。
				if (flgTurnEnd == TRUE && is.null(last_action)) {
					last_action <- "P"
					last_HP <- HP[2]
					last_state <- MTG_state(Deck)
				}
				if (flgShowHistory == TRUE) {
					cat(TurnCount)
					cat("ターン目\n")
					cat("action")
					print(action)
					cat("last_action")
					print(last_action)
					cat("flgTurnEnd")
					print(flgTurnEnd)
				}
			}
		} else {
			## 森デッキは、今までと同じ。
			## 第一メインフェイズに土地を置く
			Deck <- MTG_SetLand(Deck, ActivePlayer)
			
			## 攻撃フェイズ
			Deck <- MTG_Attack(Deck, ActivePlayer)

			## 第二メインフェイズ
			Deck <- MTG_PlaySpell(Deck, ActivePlayer)
		}
		
		WinPlayer <- MTG_CheckVictory()

		## 終了フェイズ
		Deck <- MTG_TurnEnd(Deck, ActivePlayer)
		
		## コンソールに途中経過を出力する。
		if (flgShowHistory == TRUE) {
			cat(TurnCount)
			cat("ターン目\n")
			if (ActivePlayer == 1) {
				cat("山デッキ:")
				cat(MTG_Hand(Deck, 1, TRUE))
				cat("\n")
			} else {
				cat("森デッキ:")
				cat(MTG_Hand(Deck, 2, TRUE))
				cat("\n")
			}
			print(HP)
			print(Mana)
		}
		
		if (WinPlayer != 0) {
			break
		}
		
		ActivePlayer = MTG_SwitchPlayer(ActivePlayer)
		TurnCount = TurnCount + 1
	}
	
	## 勝敗を判定する。
	if (WinPlayer == 1) {
		LosePlayer = 2
		reward = 100
	} else if (WinPlayer == 2) {
		LosePlayer = 1
		reward = 0
	} else {
		LosePlayer = 0
		reward = 30
	}
	## 最後のアクションの結果を記録する。
	reward <- reward + last_HP - HP[2]
	
	if (flgShowHistory == TRUE) {
		cat("last_state")
		print(last_state)
		cat("last_action")
		print(last_action)
		cat("reward")
		print(reward)
	}
	
	ManaBattery <<- rbind(ManaBattery, Urza(last_state, last_action, MTG_state(Deck), reward) )

	## ゲームを記録して終了。
	if (WinPlayer != 0) {
		GameLog <- data.frame(
			"RandomSeed" = RandomSeed,
			"WinPlayer" = WinPlayer,
			"FirstPlayer" = FirstPlayer,
			"HPWin" = HP[WinPlayer],
			"HPLose" = HP[LosePlayer],
			"finalTurn" = TurnCount
		)
	} else {
		GameLog <- data.frame(
			"RandomSeed" = RandomSeed,
			"WinPlayer" = 0,
			"FirstPlayer" = FirstPlayer,
			"HPWin" = HP[1],
			"HPLose" = HP[2],
			"finalTurn" = TurnCount
		)
	}
	return(GameLog)
}

## これで作成出来た貴重なManaBatteryを利用して強化学習する。

## https://cran.r-project.org/web/packages/ReinforcementLearning/vignettes/ReinforcementLearning.html

# Define reinforcement learning parameters
control <- list(alpha = 0.2, gamma = 0.4, epsilon = 0.1)

# Perform reinforcement learning
model <- ReinforcementLearning(ManaBattery, s = "State", a = "Action", r = "Reward", 
                               s_new = "NextState", iter = 1, control = control)

# Calculate optimal policy
pol <- computePolicy(model)

# Print policy
head(pol)

predict(model, data_unseen#state)

## 学習した結果に基づくアクションを返す。
MTG_getGreedyAction <- function(state) {
	action <- predict(model, state)
	return(action)
}






## ここから先がテスト用もしくは、説明用のコード


## Deck Init & Draw Test
Deck <- MTG_Init()

Deck <- MTG_Draw(Deck, 1, 7)
Deck <- MTG_Draw(Deck, 2, 7)


## Hand Test
MTG_Hand(Deck, 1)
MTG_Hand(Deck, 2)

MTG_Hand(Deck, 1, TRUE)
MTG_Hand(Deck, 2, TRUE)


## SetLand Test
Deck <- MTG_SetLand(Deck, 1)
MTG_Hand(Deck, 1, TRUE)

## PlaySpell Test
Deck <- MTG_PlaySpell(Deck, 1)
MTG_Hand(Deck, 1, TRUE)


## AccumulateKnowledge Test

TotalResult <- AccumulateKnowledge(1000, 1)

save(TotalResult, file="c:/yanagawa/R/TotalResult.dat")

load("c:/yanagawa/R/TotalResult.dat")


## 結果を確認してみる。
table(TotalResult$WinPlayer)

  1   2 
832 168 

table(TotalResult$WinPlayer, TotalResult$FirstPlayer)

      1   2
  1 417 415
  2  92  76

table(TotalResult$finalTurn)

SummaryResult <- TotalResult %>%
	group_by(finalTurn, WinPlayer) %>%
	summarize(n = n())

## グラフで表示
ggplot(data = SummaryResult) +
	geom_col(aes(x=finalTurn, y = n, fill = WinPlayer))

## グラフを保存
ggsave("c:/Yanagawa/R/pic/finalTurn.png", width = 30, height = 20, unit = "cm", dpi = 300)



## 処理時間を調べてみる

MentalNote(7, TRUE)
MentalNote(7)


## 5秒かかってるみたい
## 何処を高速化するのが一番効果があるか確認する。

TimeVault <- TimeVault %>%
	mutate(processTime = lubridate::time_length(lubridate::interval(Time, lead(Time),) ) )

TimeVault %>% arrange(desc(processTime) )


## TurnAttackとTurnPlaySpellが遅い
## forループを使っている為なので、それはやめた。
## MTG_Init内でDeckとCardsを一回だけinner_joinするように変更した。



## マリガン(意外と勝敗に関係なかった。あと、乱数固定してあるからマリガン処理入れてもおそらく同じ結果になる。)
TotalResult %>% filter(WinPlayer == 2)

MentalNote(603, TRUE)




## SetCardLibraryTop Test
## テスト用コード
Deck <- MTG_Init()
Deck <- MTG_Draw(Deck, 1, 7)
MTG_Hand(Deck, 1, TRUE)

Deck %>% filter(Status == 1)

Deck <- MTG_SetCardLibraryTop(Deck, 1, 31)
MTG_Hand(Deck, 1, TRUE)

DeckOnTop


## Mulligan Test
set.seed(603)
Deck <- MTG_Init()
Deck <- MTG_Draw(Deck, 1, 7)
MTG_Hand(Deck, 1, TRUE)

Deck <- MTG_Mulligan(Deck, 1, 1, TRUE)

Result <- MentalNote(603, TRUE, TRUE)
Result <- MentalNote(603, TRUE, FALSE)


## GoblinLore Test
Result <- GoblinLore("Random", 1, TRUE)

RandomResult <- AccumulateKnowledge(1000, 1, "GoblinLore")

save(ManaBattery, file="c:/yanagawa/R/ManaBattery_random.dat")

table(RandomResult$WinPlayer)

  0   1   2 
  2   9 989 

Result <- GoblinLore("Greedy", 1, TRUE)

